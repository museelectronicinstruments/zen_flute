

//Zen Flute Low RF version (FCC approved)
// compile with teensy 4.0/usb serial, midi, audio 600MHz
// Version 4.5 11/2021
//notes: derivative gain not active

// //***************************MIT Software License*******************************
//Copyright (c) 2021 Keith Baxter (info@museelectronicinstruments.com)
//
//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the Software is
//furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all
//copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//SOFTWARE.

//************************** End of MIT License*******************************

//This license is not a hardware license nor an implied license to hardware.
//Please support Muse Electronic Instruments (MEI) in its mission to offer
//innovative electronic instruments by purchasing the Zen Flute and other MEI products.  Thanks.

//***************************************
// libraries and global variables
//***************************************


// The following are synthesizer blocks setup with a graphical
// tool described at pjrc.com/teensy/td_libs_Audio.html
// copying the following into the tool will generate a graphical
// layout of this synth.

#if !defined(ARDUINO_TEENSY40)
#error "Please Select Teensy 4.0 Board Type"
#endif

#if !defined(SERIAL)
#error "USB MIDI not enabled. Please set USB type to 'Serial'."
#endif

#include <EEPROM.h>
#include <Audio.h>
#include "sax.h"

sax sax1; //instantiate sax using code generated by: https://faustide.grame.fr/
//brassplus sax2;

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>


// GUItool: begin automatically generated code
AudioSynthWaveformDc     dc1;            //xy=143.00001525878906,211.00000190734863
AudioSynthWaveformDc     dc2;            //xy=143.0000114440918,250.00000190734863
AudioAnalyzeNoteFrequency notefreq1;      //xy=349.00000381469727,132.00000095367432
AudioMixer4              mixer1;         //xy=359.00001525878906,206
AudioFilterStateVariable filter2;        //xy=507.00000381469727,213.00000190734863
AudioFilterStateVariable filter1;        //xy=636.0000152587891,232.00000190734863
AudioEffectFreeverb      freeverb1;      //xy=721.444465637207,166.00000190734863
AudioMixer4              mixer2;         //xy=815.444465637207,238
AudioOutputUSB           usb1;           //xy=1004.0000190734863,270.00000286102295
AudioOutputI2S           out;            //xy=1006.000020980835,221.00000190734863
AudioConnection          patchCord1(dc1, 0, mixer1, 2);
AudioConnection          patchCord2(dc2, 0, mixer1, 3);
AudioConnection          patchCord3(mixer1, 0, filter2, 0);
AudioConnection          patchCord4(filter2, 2, filter1, 0);
AudioConnection          patchCord5(filter1, 0, freeverb1, 0);
AudioConnection          patchCord6(filter1, 1, mixer2, 1);
AudioConnection          patchCord7(freeverb1, 0, mixer2, 0);
AudioConnection          patchCord8(mixer2, 0, out, 0);
AudioConnection          patchCord9(mixer2, 0, out, 1);
AudioConnection          patchCord10(mixer2, 0, usb1, 0);
AudioConnection          patchCord11(mixer2, 0, usb1, 1);
AudioConnection          patchCord12(sax1, 0, mixer1, 0);
AudioConnection          patchCord13(sax1, 0, notefreq1, 0);
// GUItool: end automatically generated code

//pin assignments Teensy 4.0
const int LEDpin = 13;
const int micInputPin = A0; //mouth microphone
const int mouthSpkrOutput = 12; //mouth speaker output pwm 12 for new RF verson, 15 otherwise
const int closeButton = 2;  //hardware is A2
const int middleButton = 1;
const int farButton = 0;
const int redPin = 5;
const int bluePin = 6;
const int greenPin = 8;
const int modePin = A9;
const int monitorPin = 4;
int WhammyPin = 17;
float whammypot = 0;

float adj = 0;

//********************************************************************
// Acoustic Volume Processor Settings
//********************************************************************

bool USB_Midi_on = true;


// tube length to frequency calculated using https://arachnoid.com/polysolve/
const float tubelength[59] = {98.00, 103.83, 110.00, 116.54, 123.47, 130.81, 138.59, 146.83, 155.56, 164.81, 174.61,
                              185.00, 196.00, 207.65, 220.00, 22.6, 2.5, 2.4, 2.38, 2.3110, 2.210, 2.0780, 1.9520,
                              1.8420, 1.7330, 1.6330, 1.5240, 1.4450, 1.3590, 1.2760, 1.1980, 1.1290, 1.0580, .9980, .9360, .8820, .8280,
                              .7790, .7320, .6890, .6470, .6080, .5730, .5370, .5050, .4740, .4470, .4200, 1567.98, 1661.22,
                              1760.00, 1864.66, 1975.53, 2093.00,
                              2217.46, 2349.32, 2489.02, 2637.02, 2793.83,
                             };


const float pressure[59] = {98.00, 103.83, 110.00, 116.54, 123.47, 130.81, 138.59, 146.83, 155.56, 164.81, 174.61,
                            185.00, 196.00, .1, .1, .1, .1, .1, .1, .1, .10, .11, .12, .12, .13, .14, .16, .16, .17, .17, .17, .18, .19, .19,
                            .20, .21, .24, .28, .32, .36, .38, .40, .43, .46, .48, .51, .60, .67,
                            .7, .71, 1760.00, 1864.66, 1975.53, 2093.00,
                            2217.46, 2349.32, 2489.02, 2637.02, 2793.83,
                           };



const float chromatic[65] = {98.00, 103.83, 110.00, 116.54, 123.47, 130.81, 138.59, 146.83, 155.56, 164.81, 174.61,
                             185.00, 196.00, 207.65, 220.00, 233.08, 246.94, 261.63, 277.18, 293.66,
                             311.13, 329.63, 349.23, 369.99, 392.00, 415.30, 440.00, 466.16, 493.88,
                             523.25, 554.37, 587.33, 622.25, 659.25, 698.46, 739.99, 783.99, 830.61,
                             880.00, 932.33, 987.77, 1046.50, 1108.73, 1174.66, 1244.51, 1318.51,
                             1396.91, 1479.98, 1567.98, 1661.22, 1760.00, 1864.66, 1975.53, 2093.00,
                             2217.46, 2349.32, 2489.02, 2637.02, 2793.83, 2637.02, 2793.83, 2959.96, 3135.96,
                             3322.44, 3520.00
                            };

const int midiconvert[59] = {43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
                             53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
                             63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
                             73, 74, 75, 76, 77, 78, 79, 80, 81, 82,
                             83, 84, 85, 86, 87, 88, 89, 90, 91, 92,
                             93, 94, 95, 96, 97, 98, 99, 100, 101,
                            };

//int scalefilter[31] = {2, 4, 5, 7, 9, 10, 12, 14, 16, 17, 19, 21, 22, 24, 26,
//                       28, 29, 31, 33, 34, 36, 38, 40, 41, 43, 45, 46, 48, 41, 41, 41
//                      }; //cmaj



int scalefilter[31] = {3, 6, 8, 11, 13, 15, 18, 20, 23, 25, 27, 30, 32, 35, 37,
                       39, 42, 44, 47, 49, 51, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58
                      }; //black keys




int scale_type = 0;


bool scaletemplate1[22] = {1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0}; //c
bool scaletemplate2[22] = {0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1}; //b
bool scaletemplate3[22] = {1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0}; //a#
bool scaletemplate4[22] = {1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1}; //c
bool scaletemplate5[22] = {0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1}; //c
bool scaletemplate6[22] = {1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0}; //c
bool scaletemplate7[22] = {0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1}; //c
bool scaletemplate8[22] = {1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0}; //c
bool scaletemplate9[22] = {1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1}; //c
bool scaletemplate10[22] = {0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1}; //c
bool scaletemplate11[22] = {1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0}; //c
bool scaletemplate12[22] = {0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1}; //c
bool scaletemplate13[22] = {1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0}; //c




////maps between chromatic and different scales
////C
//const int scalefilter1[31] = { 2, 4, 5, 7, 9, 10, 12, 14, 16, 17, 19, 21, 22, 24, 26, 28, 29, 31, 33, 34, 36, 38, 40, 41, 43, 45, 46, 48, 50};
////B
//const int scalefilter2[31] = { 3, 4, 6, 8, 9, 11, 13, 15, 16, 18, 20, 21, 23, 25, 27, 28, 30, 32, 33, 35, 37, 39, 40, 42, 44, 45, 47, 49};
////A#
//const int scalefilter3[31] = { 2, 3, 5, 7, 8, 10, 12, 14, 15, 17, 19, 20, 22, 24, 26, 27, 29, 31, 32, 34, 36, 38, 39, 41, 43, 44, 46, 48, 50};
////A
//const int scalefilter4[31] = { 2, 4, 6, 7, 9, 11, 13, 14, 16, 18, 19, 21, 23, 25, 26, 28, 30, 31, 33, 35, 37, 38, 40, 42, 43, 45, 47, 49, 50};
////G#
//const int scalefilter5[31] = { 3, 5, 6, 8, 10, 12, 13, 15, 17, 18, 20, 22, 24, 25, 27, 29, 30, 32, 34, 36, 37, 39, 41, 42, 44, 46, 48, 49};
////G
//const int scalefilter6[31] = { 2, 4, 5, 7, 9, 11, 12, 14, 16, 17, 19, 21, 23, 24, 26, 28, 29, 31, 33, 35, 36, 38, 40, 41, 43, 45, 47, 48, 50};
////F#
//const int scalefilter7[31] = { 3, 4, 6, 8, 10, 11, 13, 15, 16, 18, 20, 22, 23, 25, 27, 28, 30, 32, 34, 35, 37, 39, 40, 42, 44, 46, 47, 49};
////F
//const int scalefilter8[31] = {3, 5, 7, 9, 10, 12, 14, 15, 17, 19, 21, 22, 24, 26, 27, 29, 31, 33, 34, 36, 38, 39, 41, 43, 45, 46, 48, 50};
////E
//const int scalefilter9[31] = { 2, 4, 6, 8, 9, 11, 13, 14, 16, 18, 20, 21, 23, 25, 26, 28, 30, 32, 33, 35, 37, 38, 40, 42, 44, 45, 47, 49, 50};
////D#
//const int scalefilter10[31] = { 3, 5, 7, 8, 10, 12, 13, 15, 17, 19, 20, 22, 24, 25, 27, 29, 31, 32, 34, 36, 37, 39, 41, 43, 44, 46, 48, 49};
////D
//const int scalefilter11[31] = { 2, 4, 6, 7, 9, 11, 12, 14, 16, 18, 19, 21, 23, 24, 26, 28, 30, 31, 33, 35, 36, 38, 40, 42, 43, 45, 47, 48, 50};
////C#
//const int scalefilter12[31] = { 3, 5, 6, 8, 10, 11, 13, 15, 17, 18, 20, 22, 23, 25, 27, 29, 30, 32, 34, 35, 37, 39, 41, 42, 44, 46, 47, 49};


float rootfreq = 0;
float thirdfreq = 0;
float fifthfreq = 0;
float secondfreq = 0;
float sixthfreq = 0;
float target1 = 0;
float target2 = 0;
float target3 = 0;
//float target4 = 0;
//float target5 = 0;

float justifiedtarget1 = 0;
float justifiedtarget2 = 0;
float justifiedtarget3 = 0;

//LUT for mouthspeaker volume

int closestLUTnumber = 0;


//*******Sampling ISR variables and objects*******
// Create an IntervalTimer object to call buffer ISR
IntervalTimer samplingTimer;
const int BUFSIZE = 300;//610;
static volatile int h;  //buffferindex
static volatile int drivebuffer[BUFSIZE];
static volatile int micbuffer[BUFSIZE];
static volatile byte micval, driveval, monitorval;
static volatile int duration = 0;
static float sineincrement = 1;
static unsigned long ISRlasttime = 0;
//https://www.wolframalpha.com/input/?i=table+round%28127*%28sin%282*pi*t%2F100%29%2B1%29%29+from+0+to+99
const int16_t sinetable[100] = {127, 135, 143, 151, 159, 166, 174, 181, 188,
                                195, 202, 208, 214, 220, 225, 230, 234, 238, 242, 245, 248, 250, 252, 253,
                                254, 254, 254, 253, 252, 250, 248, 245, 242, 238, 234, 230, 225, 220, 214,
                                208, 202, 195, 188, 181, 174, 166, 159, 151, 143, 135, 127, 119, 111, 103,
                                95, 88, 80, 73, 66, 59, 52, 46, 40, 34, 29, 24, 20, 16, 12, 9, 6, 4, 2, 1,
                                0, 0, 0, 1, 2, 4, 6, 9, 12, 16, 20, 24, 29, 34, 40, 46, 52, 59, 66, 73, 80,
                                88, 95, 103, 111, 119
                               };
static bool earliest = true;
static int risingedge = 0;


//phase lock variables
//25 array elements

bool phasegainboost = 0;
bool volumeboost = 0;
float factoryphasegainset[25] = {4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                                 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6,
                                };
float factoryderivativegainset[25] = { 0, 0, 0, 0, 0, 0, 0, 0,
                                       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                                     };
float factoryphasetargetset[25] = {0.10, 0.11, 0.12, 0.07, 0.10, 0.10, 0.10, 0.10, 0.10, 0.10, 0.10, 0.10,

                                   0.10, 0.10, 0.10, 0.10, 0.10, 0.10, 0.10, 0.10, 0.10, 0.32, 0.32, 0.50, 0.40,
                                  };

float factoryspeakergainset[25] = {0.16, 0.30, 0.20, 0.20, 0.20, 0.20, 0.14, 0.12, 0.11, 0.09, 0.09, 0.06,

                                   0.06, 0.05, 0.05, 0.03, 0.03, 0.03, 0.03, 0.03, 0.07, 0.04, 0.04, 0.16, 0.16,

                                  };

//standard values for manufactured flutes
//bool phasegainboost = 0;
//bool volumeboost = 0;
//float factoryphasegainset[25] = {1.00, 1.00, 3.0, 3.50, 4.00, 4.50, 5, 6.00, 6.00, 6.00, 7.00, 9.00,
//                                 9.00, 10.00, 11.00, 12.00, 13.00, 13.00, 13.00, 13.00, 13.00, 15.00, 15.00, 3.00, 0.00,
//                                };
//float factoryderivativegainset[25] = { 0, 0, 0, 0, 0, 0, 0, 0,
//                                       0, 0, 0, 0, 0, 0, 0, 0, 0, 0,, 0, 0, 0, 0, 0
//                                     };
//float factoryphasetargetset[25] = {0.10, 0.11, 0.05, 0.07, 0.10, 0.10, 0.10, 0.12, 0.13, 0.16, 0.22, 0.22,
//                                   0.22, 0.26, 0.27, 0.3, 0.31, 0.32, 0.33, 0.35, 0.35, 0.40, 0.32, 0.50, 0.40,
//                                  };
//
//float factoryspeakergainset[25] = {.05, .05, .05, .05, .05, .05,
//                                   .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05,
//                                   .05, .05, .05, .05, .05, .05, .05, 0.05,
//                                  };


float phasegainset[25];
float derivativegainset[25];
float phasetargetset[25];
float speakergainset[25];

float phasegain = 3;

float derivativegain = 0;
float phasetarget = .25;
float speakergain = .01;
float phaseshift = 0;
float phaseshift2 = 0;
float phaseshiftdegrees = 0;
float phaseerror = 0;
float previousphaseerror = 0;
float phaseerrordegrees = 0;
float lastphaseerror = 0;
float drivefrequency = 880;
int lastdrivefrequency = 0;
float proportional = 0; //PPL gain block proportional term
float derivative = 0; //PPL gain block derivative term
float fderivative = 0;
int tuningband = 0; //coarse bins for tuning as function of pitch
float boost = 0;



//gain boost variables
unsigned long lastcheck;
float lastfrequency;
float slopemagnitude = 0;
int gaincorrect = 0;
unsigned long boosttimeout = 0;


int tempdrivebuffer[BUFSIZE];
int tempmicbuffer[BUFSIZE];
int startdrive = 0;
float averagemic = 0;
float microphonelevel = 0;
int startmic = 0;
int endmic = 0;
bool found = false;
int lastsample = 0;
float sinelength = 0;
bool capture = false;

// curvefitting variables for finding zero crossings accurately in noise
float ymean = 0;
float xmean = 0;
float lineslopenumerator = 0;
float lineslopedenominator = 0;
float lineslope = 0;
float yintercept = 0;
float precisemicstart = 0;
float precisemicend = 0;


//const bool activateTuning = false; //activate utility for tuning model
bool dropOctave = false;
// autoadjust AGC variables
const float SCALESIZE = 30; //number of notes that can be identified (!todo bigger?
const float TOPFREQ = chromatic[46]; //highest frequncy in scale was 1479 hz
const float BOTTOMFREQ = chromatic[27]; //lowest note is 523 hz  /was 25

//closest-note  variables
float closestfrequency = 0;
int closestscalenumber = 0;

//float delta = 0;
//float floatdelta = 0;
float driveerror = 9999;
//float floatdriveerror = 0;

//hysteresis
int hyster_closest_scale_number = 0;
float hysterclosestnote = 0;
int hyster_last_closest_scale_number = 0;
//int closest_chromatic_note_number = 0;
bool newnote = 0;
int hysterpreviousplayednotenumber1 = 0;
int hysterpreviousplayednotenumber2 = 0;
int hysterpreviousplayednotenumber3 = 0;
int hysteresisamount = 5; //smaller is more hysteresis  1/5 here
//int phasestyle = 0;



//********************************************************************
// UI variables
//********************************************************************

bool cherry1 = false;
bool cherry2 = false;
bool cherry3 = false;
bool do1once = false;
bool do2once = false;
bool do3once = false;
unsigned long bouncetimerA1 = 0;
unsigned long bouncetimerB1 = 0;
unsigned long bouncetimerA2 = 0;
unsigned long bouncetimerB2 = 0;
unsigned long bouncetimerA3 = 0;
unsigned long bouncetimerB3 = 0;

unsigned long offtimer = 0;
bool modebutton = false;
unsigned long bouncetimer3 = 0;
int modecount = 1; //start at 1 to signal eeprom empty when 0
bool modeupdate = false;
int lastmodecount = 1;
unsigned long uncolor = 0;

//fadein variables

//int playstate = 0;


bool button1toggle = true;
bool button2toggle = true;
bool button3toggle = true;

unsigned long sticktimer = 0;
unsigned long bumptimer = 0;
unsigned long bendtimer = 0;
int bumpcount = 0;
int bump = 0;
bool bumptoggle = false;
unsigned long ontime = 0;
unsigned long offtime = 0;
int bendcount = 0;
int bend = 0;
bool bendtoggle = false;

bool stickoverride = 0;
float locktarget1 = 0;
float locktarget2 = 0;
float locktarget3 = 0;

//bool instantbeat = false;
bool cherry1truetoggle = true;
bool cherry2truetoggle = true;
bool cherry3truetoggle = true;
bool cherry1falsetoggle = true;
bool cherry2falsetoggle = true;
bool cherry3falsetoggle = true;
int  binarystate = 0;
int  lastbinarystate = 6;
bool binarystatetoggle0 = false;
bool binarystatetoggle1 = false;
bool binarystatetoggle2 = false;
bool binarystatetoggle3 = false;



//********************************************************************
// SAVE VARAIBLES
//********************************************************************

bool savetopreset = false;
int targetpreset = 0;
int resettoggle = 0;
int eepromsavetoggle = 0;
bool restoretofactory = false;
int scaleNumber = 0;
bool dotheeepromsave = false;
bool dotheGUIupdate = false;
bool dothefactoryreset = false;
bool dothetuningsave = false;
bool dothetuningsreset = false;
bool dotheautoscaleset = false;

bool loadtoggle = false;
//********************************************************************
// GUI variables
//********************************************************************

int category = 0;
long int fvalue = 999;
bool GUIactivated = false;

//********************************************************************
// Debugging variables
//********************************************************************

unsigned long last_time = millis();
//tuner program
//int forceMode = 4; //uses whammypot to set PPL variables
//float phasetargetforced = .25;
//float phasegainforced = .25;
//float drivefrequencyforced = 880;
//float derivativegainforced = 0;
//float AGCsmoothforced = 1;
//float whammyfrequency = 0;

bool LEDtoggle = false;
int displayMode = 0; //0 is synth control, 1 is drum; 2 is save, 3 is debug
int countdisplay = 0;
unsigned long profiledelta = 0;
unsigned long profiletimer = 0;
bool onetime = true;
//print variables and profiling values
unsigned long printusec = 0;//
unsigned long printusec2 = 0;//
unsigned long printusec3 = 0;//
unsigned long lastprintusec = 0;
unsigned long lastprintusec2 = 0;
int refreshcontrols = 0;


//sweeping variables (for testing only)
int sweepy = 440;
unsigned long usec = 0;//special variable that increments on microseconds
unsigned long lastusec = 0;
unsigned long usec2 = 0;//special variable that increments on microseconds
unsigned long lastusec2 = 0;

//********************************************************************
// Misc variables
//********************************************************************

//sleep timer when not played in a while
unsigned long sleeptimer = 0;
unsigned long alivetimer = 0;
bool woken = false;
bool wokenstall = false;
unsigned long wokentime = 0;
bool lastwoken = true;


//monitor variables
float monitorgain = 1;
float monitorgainset = 1;
float performancegain = 1;

//LUT for monitor volume//not used right now
const float volumecurve[49] =
{ .05, .05, .05, .05, .05, .05, .05, .05, .05, .05,
  .05, .05, .05, .05, .05, .05, .05, .05, .05, .05,
  .05, .05, .05, .05, .05, .05, .05, .05, .05, .05,
  .05, .05, .05, .05, .05, .05, .05, .05, .05, .05,
  .05, .05, .05, .05, .05, .05, .05, .05, .05,
};

float whammyvalue;
float lastwhammyvalue = 0;

unsigned long freqprint = 0;
//float monitorvolume = 0;


float reverb_amount = .2;
float reverb_size = 0.9;
float reverb_damping = 0.999;




//********************************************************************
// Factory preset Variables
//********************************************************************

//bool EEPROMsource = false;
byte dynamic_byte_parameter[251];
int integerinput[251];


//preset_byte_parameters


bool updatetoggle = false;

byte preset_byte_parameter1[150] = //blank
{ //first digit is a pad cause java
  0, 35, 130, 209, 5, 6, 175, 133, 15, 129,
  0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,
  0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5,
  5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 16,
  0, 10, 11, 12, 7, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 32, 32,
  50, 40, 0, 0, 0, 19, 0, 16, 30, 20, 20, 20, 20,
  14, 12, 11, 9, 9, 6, 6, 5, 5, 3, 3, 3, 3, 3, 7, 4,
  4, 16, 16, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24

};

byte preset_byte_parameter2[250] = //ruby
{
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
};

byte preset_byte_parameter3[250] = //rose
{
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
};


byte preset_byte_parameter4[250] = //shamrock
{
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
};


byte preset_byte_parameter5[250] = //sun
{
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
};


byte preset_byte_parameter6[250] = //artic
{
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
};

byte preset_byte_parameter7[250] = //pumpkin
{
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
};

byte preset_byte_parameter8[250] = //lapis
{
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
};

byte preset_byte_parameter9[250] = //porcelain
{
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
};


float LPfilterRes = .5; //dc blocking filter
int LPfilterFreq = 1000;
float HPfilterRes = 100; //mute filter
int HPfilterFreq = 100;

int openfilter[30];
bool noteA4 = false;
bool noteAs4  = false;
bool noteB4 = false;
bool noteC5 = false;
bool noteCs5  = false;
bool noteD5 = false;
bool noteDs5  = false;
bool noteE5 = false;
bool noteF5 = false;
bool noteFs5  = false;
bool noteG5 = false;
bool noteGs5  = false;
bool noteA5 = false;
bool noteAs5  = false;
bool noteB5 = false;
bool noteC6 = false;
bool noteCs6  = false;
bool noteD6 = false;
bool noteDs6  = false;
bool noteE6 = false;
bool noteF6 = false;
bool noteFs6 = false;

bool chordPreset = false;
bool presetLoad = false;






// ***************************************
//***************************************
// Setup
//***************************************
//***************************************
void setup()
{
  Serial.begin(38400);
  // audio bus between synth objects.  Set by looking at CPU usage
  AudioMemory(200);


  analogWriteResolution(8); //do I need this?
  analogWriteFrequency(mouthSpkrOutput, 30000);
  analogWriteFrequency(monitorPin, 30000);
  analogReadResolution(8);//was 12

  samplingTimer.begin(grabdata, 20);  // ISR to grab data (mic and drive wave)every 20 us
  samplingTimer.priority(200);  //0 is bad make this get interrupted by something, why?
  delay(1000);

  //initialize variables from factory preset 1
  for (int x = 41; x < 66; x++) preset_byte_parameter1[x] = byte(factoryphasegainset[x - 41]);
  for (int x = 71; x < 96; x++) preset_byte_parameter1[x] = byte(factoryphasetargetset[x - 71] * 100);
  for (int x = 101; x < 126; x++) preset_byte_parameter1[x] = byte(factoryspeakergainset[x - 101] * 100);
  for (int x = 0; x < 150; x++) dynamic_byte_parameter[x] = preset_byte_parameter1[x];
  int test = EEPROM.read(1077); //blank eeprom bit
  if (test == 0)
  {
    for (int x = 1001; x < 1025; x++)phasegainset[x - 1001] = EEPROM.read(x);
    for (int x = 1026; x < 1050; x++)phasetargetset[x - 1026] = float(EEPROM.read(x)) / 100;
    for (int x = 1051; x < 1075; x++)speakergainset[x - 1051] = float(EEPROM.read(x)) / 100;
  } else
  {
    for (int x = 0; x < 25; x++)phasegainset[x] = factoryphasegainset[x];
    for (int x = 0; x < 25; x++)phasetargetset[x] = factoryphasetargetset[x];
    for (int x = 0; x < 25; x++)speakergainset[x] = factoryspeakergainset[x];
  }

  delay(100);

  UpdateLocalVariables();//??


  //***************I/O*****************
  // pins 7, 20 and 213 used by i2s interface--so leave alone

  pinMode(LEDpin, OUTPUT); //led
  pinMode(micInputPin, INPUT); //microphone A0
  pinMode(mouthSpkrOutput, OUTPUT); //mouth sine output
  pinMode(closeButton, INPUT_PULLUP);
  pinMode(farButton, INPUT_PULLUP);
  pinMode(middleButton, INPUT_PULLUP);

  pinMode(monitorPin, OUTPUT);
  pinMode(WhammyPin, INPUT);
  analogWrite(redPin, 256); //need to set pinmode??
  analogWrite(bluePin, 256);
  analogWrite(greenPin, 256);
  pinMode(modePin, INPUT_PULLUP);

  pinMode(A3, INPUT);  //potentiometer
  pinMode(A4, INPUT);  //not needed


  pinMode(WhammyPin, INPUT);
  mixer1.gain(0, 4);
  mixer1.gain(1, 0);
  mixer1.gain(2, 0);
  mixer1.gain(3, 0);

  mixer2.gain(0, .2); //reverb amount
  mixer2.gain(1, .8);

  sax1.setParamValue("breathGain", .1);
  sax1.setParamValue("breathCutoff", 2000);
  sax1.setParamValue("vibratoFreq", 5);
  sax1.setParamValue("vibratoGain", .3);

  filter1.resonance(LPfilterRes = .5); //lowpass
  filter1.frequency(LPfilterFreq);
  filter2.resonance(HPfilterRes); //highpass/dc blocking
  filter2.frequency(HPfilterFreq = .5);
  notefreq1.begin(.5);

}

//***************************************
//***************************************
// Main Loop
//***************************************
//***************************************

void loop()
{

  //  profiledelta = micros() - profiletimer;
  //  profiletimer = micros();

  if (capture == true) //have a set of audio data?, if not avoid entire loop until data is captured
  {
    //*************************************************
    //This is the phase tracker
    //monitor the microphone wave and driving speaker to determine
    //the phase shift indicative of resonance--use this phase
    //difference in a phase locked loop to control the drive
    //frequency to measure the oral cavity volume
    //by its resonant frequency
    //*************************************************


    /////////////////////////////////////////
    //detect driving signal, start and length
    /////////////////////////////////////////
    //do this to zero array at current sample for simplicity

    for (int x = 0; x < BUFSIZE; x++)
    {
      tempdrivebuffer[x] = drivebuffer[x];
      tempmicbuffer[x] = micbuffer[x];
    }

    //***********************************************************
    //********zero crossing phase detection ********************
    //***********************************************************

    //determine sine length at this frequency
    if (drivefrequency < 0) drivefrequency = 1;  //nan bug figure out later
    sinelength = ((1 / drivefrequency) / .000020); //one sample every 20 usec, **sinelength is samples

    /////////////////////////////////////////
    //detect drive signal signal start
    /////////////////////////////////////////

    startdrive = risingedge; //micbuffer location of drive signal (+zero cross) now provided by ISR

    /////////////////////////////////////////
    //detect microphone signal start
    /////////////////////////////////////////

    //MICROPHONE UP ZERO CROSSING
    //find average of buffer for rough zero crossing calculation
    averagemic = 0;
    //int peakmic = -999;
    for (int x = 0; x < BUFSIZE; x++)
    {
      averagemic = averagemic + tempmicbuffer[x];
      //if (tempmicbuffer[x] > peakmic) peakmic = tempmicbuffer[x];
    }
    averagemic = int(averagemic / BUFSIZE);
    //microphonelevel = (peakmic - averagemic); //now use audio widget
    //averagecount++;

    //find positive going zero crossing
    found = false;
    lastsample = 2000;
    for (int x = startdrive; x < BUFSIZE; x++) //start at drive signal zero crossing
    {
      if (found == false)
      {
        if ((lastsample <= averagemic) && (tempmicbuffer[x] > averagemic))
        {
          found = true;
          startmic = x;  //up zero cross of mic
        }
        lastsample = tempmicbuffer[x];
      }
    }

    //find negative going zero crossing
    found = false;
    lastsample = 2000;
    for (int x = startmic; x < BUFSIZE; x++) //start at drive signal zero crossing
    {
      if (found == false)
      {
        if ((lastsample >= averagemic) && (tempmicbuffer[x] < averagemic))
        {
          found = true;
          endmic = x;  //next down zero cross of mic
        }
        lastsample = tempmicbuffer[x];
      }
    }

    //curvefit around up zero crossing for subsample interpolation
    ymean = 0;
    for (int x = startmic - 5; x < startmic + 6; x++) ymean = ymean + micbuffer[x];
    ymean = ymean / 11;
    xmean = startmic;
    lineslopenumerator = 0;
    lineslopedenominator = 0;
    for (int x = startmic - 5; x < startmic + 6; x++)
    {
      lineslopenumerator = ((x - xmean) * (micbuffer[x] - ymean));
      lineslopedenominator = (x - xmean) * (x - xmean);
    }
    lineslope = lineslopenumerator / lineslopedenominator;
    yintercept = ymean - lineslope * xmean;
    precisemicstart = ((averagemic - yintercept) / lineslope);


    //curvefit around down zero crossing for subsample interpolation
    ymean = 0;
    for (int x = endmic - 5; x < endmic + 6; x++) ymean = ymean + micbuffer[x];
    ymean = ymean / 11;
    xmean = endmic;
    lineslopenumerator = 0;
    lineslopedenominator = 0;
    for (int x = endmic - 5; x < endmic + 6; x++)
    {
      lineslopenumerator = ((x - xmean) * (micbuffer[x] - ymean));
      lineslopedenominator = (x - xmean) * (x - xmean);
    }
    lineslope = lineslopenumerator / lineslopedenominator;
    yintercept = ymean - lineslope * xmean;
    precisemicend = ((averagemic - yintercept) / lineslope);


    phaseshift = precisemicstart - startdrive; //the sample # measure of the phase delay

    int halfwave = int(sinelength / 2);
    phaseshift2 = precisemicend - (startdrive + halfwave); //the sample # measure of the phase delay

    phaseshift = (phaseshift2 + phaseshift) / 2; //corrects waveform zero shift?

    //handles an odd phase shift rollover at low frequecies
    if (phaseshift > (sinelength / 2)) phaseshift = sinelength - phaseshift;

    phaseshiftdegrees = phaseshift / sinelength * 360; // for display
    if (isnan(sinelength)) sinelength = 100; //weird startup bug--figure out later

    //compute phase error in time then degrees
    //    if (forceMode == 1)phaseerror = phaseshift - (sinelength * phasetargetforced); //tuning mode
    //    else phaseerror = phaseshift - (sinelength * phasetarget);
    phaseerror = phaseshift - (sinelength * phasetarget);
    phaseerrordegrees = phaseerror / sinelength * 360;


    /////////////////////////////////
    //determine loop gain factors (P and D) according to current pitch bin !!!!!!!!!!
    /////////////////////////////////

    //apply different loop gains depending on note frequency in 25 notes

    if ((drivefrequency <= chromatic[25]) && (drivefrequency > chromatic[24])) //note 2 !!!!!!!
    {
      tuningband = 0;//415
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[0] + (phasegainset[1] - phasegainset[0]) *
                  ((drivefrequency - chromatic[24]) / (chromatic[25] - chromatic[24])); //these are the frequency values bounding the top bin
      //interpolate derivative gain
      derivativegain = derivativegainset[0] + (derivativegainset[1] - derivativegainset[0]) *
                       ((drivefrequency - chromatic[24]) / (chromatic[25] - chromatic[24]));
      //interpolate  phase target
      phasetarget = phasetargetset[0] + (phasetargetset[1] - phasetargetset[0]) *
                    ((drivefrequency - chromatic[24]) / (chromatic[25] - chromatic[24]));
      //interpolate  speaker gain
      speakergain = speakergainset[0] + (speakergainset[1] - speakergainset[0]) *
                    ((drivefrequency - chromatic[24]) / (chromatic[25] - chromatic[24]));

    }
    else if (drivefrequency <= chromatic[26]) //493-659
    {
      tuningband = 1;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[1] + (phasegainset[2] - phasegainset[1]) *
                  ((drivefrequency - chromatic[25]) / (chromatic[26] - chromatic[25]));
      //interpolate derivative gain
      derivativegain = derivativegainset[1] + (derivativegainset[2] - derivativegainset[1]) *
                       ((drivefrequency - chromatic[25]) / (chromatic[26] - chromatic[25]));
      //interpolate  phase target
      phasetarget = phasetargetset[1] + (phasetargetset[2] - phasetargetset[1]) *
                    ((drivefrequency - chromatic[25]) / (chromatic[26] - chromatic[25]));
      //interpolate  speaker gain
      speakergain = speakergainset[1] + (speakergainset[2] - speakergainset[1]) *
                    ((drivefrequency - chromatic[25]) / (chromatic[26] - chromatic[25]));
    }
    else if (drivefrequency <= chromatic[27]) //660-830
    {
      tuningband = 2;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[2] + (phasegainset[3] - phasegainset[2]) *
                  ((drivefrequency - chromatic[26]) / (chromatic[27] - chromatic[26]));
      //interpolate derivative gain
      derivativegain = derivativegainset[2] + (derivativegainset[3] - derivativegainset[2]) *
                       ((drivefrequency - chromatic[26]) / (chromatic[27] - chromatic[26]));
      //interpolate  phase target
      phasetarget = phasetargetset[2] + (phasetargetset[3] - phasetargetset[2]) *
                    ((drivefrequency - chromatic[26]) / (chromatic[27] - chromatic[26]));
      //interpolate  speaker gain
      speakergain = speakergainset[2] + (speakergainset[3] - speakergainset[2]) *
                    ((drivefrequency - chromatic[26]) / (chromatic[27] - chromatic[26]));
    }
    else if (drivefrequency <= chromatic[28]) //831-1046
    {
      tuningband = 3;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[3] + (phasegainset[4] - phasegainset[3]) *
                  ((drivefrequency - chromatic[27]) / (chromatic[28] - chromatic[27]));
      //interpolate derivative gain
      derivativegain = derivativegainset[3] + (derivativegainset[4] - derivativegainset[3]) *
                       ((drivefrequency - chromatic[27]) / (chromatic[28] - chromatic[27]));
      //interpolate  phase target
      phasetarget = phasetargetset[3] + (phasetargetset[4] - phasetargetset[3]) *
                    ((drivefrequency - chromatic[27]) / (chromatic[28] - chromatic[27]));
      //interpolate  speaker gain
      speakergain = speakergainset[3] + (speakergainset[4] - speakergainset[3]) *
                    ((drivefrequency - chromatic[27]) / (chromatic[28] - chromatic[27]));
    }
    else if (drivefrequency <= chromatic[29]) //1044-1244
    {
      tuningband = 4;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[4] + (phasegainset[5] - phasegainset[4]) *
                  ((drivefrequency - chromatic[28]) / (chromatic[29] - chromatic[28]));
      //interpolate derivative gain
      derivativegain = derivativegainset[4] + (derivativegainset[5] - derivativegainset[4]) *
                       ((drivefrequency - chromatic[28]) / (chromatic[29] - chromatic[28]));
      //interpolate  phase target
      phasetarget = phasetargetset[4] + (phasetargetset[5] - phasetargetset[4]) *
                    ((drivefrequency - chromatic[28]) / (chromatic[29] - chromatic[28]));
      //interpolate  speaker gain
      speakergain = speakergainset[4] + (speakergainset[5] - speakergainset[4]) *
                    ((drivefrequency - chromatic[28]) / (chromatic[29] - chromatic[28]));
    }

    else if (drivefrequency <= chromatic[30]) //1245-1661
    {
      tuningband = 5;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[5] + (phasegainset[6] - phasegainset[5]) *
                  ((drivefrequency - chromatic[29]) / (chromatic[30] - chromatic[29]));
      //interpolate derivative gain
      derivativegain = derivativegainset[5] + (derivativegainset[6] - derivativegainset[5]) *
                       ((drivefrequency - chromatic[29]) / (chromatic[30] - chromatic[29]));
      //interpolate  phase target
      phasetarget = phasetargetset[5] + (phasetargetset[6] - phasetargetset[5]) *
                    ((drivefrequency - chromatic[29]) / (chromatic[30] - chromatic[29]));
      //interpolate  speaker gain
      speakergain = speakergainset[5] + (speakergainset[6] - speakergainset[5]) *
                    ((drivefrequency - chromatic[29]) / (chromatic[30] - chromatic[29]));
    }

    else if (drivefrequency <= chromatic[31]) //1245-1661
    {
      tuningband = 6;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[6] + (phasegainset[7] - phasegainset[6]) *
                  ((drivefrequency - chromatic[30]) / (chromatic[31] - chromatic[30]));
      //interpolate derivative gain
      derivativegain = derivativegainset[6] + (derivativegainset[7] - derivativegainset[6]) *
                       ((drivefrequency - chromatic[30]) / (chromatic[31] - chromatic[30]));
      //interpolate  phase target
      phasetarget = phasetargetset[6] + (phasetargetset[7] - phasetargetset[6]) *
                    ((drivefrequency - chromatic[30]) / (chromatic[31] - chromatic[30]));
      //interpolate  speaker gain
      speakergain = speakergainset[6] + (speakergainset[7] - speakergainset[6]) *
                    ((drivefrequency - chromatic[30]) / (chromatic[31] - chromatic[30]));
    }

    else if (drivefrequency <= chromatic[32]) //1245-1661
    {
      tuningband = 7;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[7] + (phasegainset[8] - phasegainset[7]) *
                  ((drivefrequency - chromatic[31]) / (chromatic[32] - chromatic[31]));
      //interpolate derivative gain
      derivativegain = derivativegainset[7] + (derivativegainset[8] - derivativegainset[7]) *
                       ((drivefrequency - chromatic[31]) / (chromatic[32] - chromatic[31]));
      //interpolate  phase target
      phasetarget = phasetargetset[7] + (phasetargetset[8] - phasetargetset[7]) *
                    ((drivefrequency - chromatic[31]) / (chromatic[32] - chromatic[31]));
      //interpolate  speaker gain
      speakergain = speakergainset[7] + (speakergainset[8] - speakergainset[7]) *
                    ((drivefrequency - chromatic[31]) / (chromatic[32] - chromatic[31]));
    }

    else if (drivefrequency <= chromatic[33]) //1245-1661
    {
      tuningband = 8;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[8] + (phasegainset[9] - phasegainset[8]) *
                  ((drivefrequency - chromatic[32]) / (chromatic[33] - chromatic[32]));
      //interpolate derivative gain
      derivativegain = derivativegainset[8] + (derivativegainset[9] - derivativegainset[8]) *
                       ((drivefrequency - chromatic[32]) / (chromatic[33] - chromatic[32]));
      //interpolate  phase target
      phasetarget = phasetargetset[8] + (phasetargetset[9] - phasetargetset[8]) *
                    ((drivefrequency - chromatic[32]) / (chromatic[33] - chromatic[32]));
      //interpolate  speaker gain
      speakergain = speakergainset[8] + (speakergainset[9] - speakergainset[8]) *
                    ((drivefrequency - chromatic[32]) / (chromatic[33] - chromatic[32]));
    }

    else if (drivefrequency <= chromatic[34]) //1245-1661
    {
      tuningband = 9;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[9] + (phasegainset[10] - phasegainset[9]) *
                  ((drivefrequency - chromatic[33]) / (chromatic[34] - chromatic[33]));
      //interpolate derivative gain
      derivativegain = derivativegainset[9] + (derivativegainset[10] - derivativegainset[9]) *
                       ((drivefrequency - chromatic[33]) / (chromatic[34] - chromatic[33]));
      //interpolate  phase target
      phasetarget = phasetargetset[9] + (phasetargetset[10] - phasetargetset[9]) *
                    ((drivefrequency - chromatic[33]) / (chromatic[34] - chromatic[33]));
      //interpolate  speaker gain
      speakergain = speakergainset[9] + (speakergainset[10] - speakergainset[9]) *
                    ((drivefrequency - chromatic[33]) / (chromatic[34] - chromatic[33]));
    }

    else if (drivefrequency <= chromatic[35]) //1245-1661
    {
      tuningband = 10;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[10] + (phasegainset[11] - phasegainset[10]) *
                  ((drivefrequency - chromatic[34]) / (chromatic[35] - chromatic[34]));
      //interpolate derivative gain
      derivativegain = derivativegainset[10] + (derivativegainset[11] - derivativegainset[10]) *
                       ((drivefrequency - chromatic[34]) / (chromatic[35] - chromatic[34]));
      //interpolate  phase target
      phasetarget = phasetargetset[10] + (phasetargetset[11] - phasetargetset[10]) *
                    ((drivefrequency - chromatic[34]) / (chromatic[35] - chromatic[34]));
      //interpolate  speaker gain
      speakergain = speakergainset[10] + (speakergainset[11] - speakergainset[10]) *
                    ((drivefrequency - chromatic[34]) / (chromatic[35] - chromatic[34]));
    }

    else if (drivefrequency <= chromatic[36]) //1245-1661
    {
      tuningband = 11;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[11] + (phasegainset[12] - phasegainset[11]) *
                  ((drivefrequency - chromatic[35]) / (chromatic[36] - chromatic[35]));
      //interpolate derivative gain
      derivativegain = derivativegainset[11] + (derivativegainset[12] - derivativegainset[11]) *
                       ((drivefrequency - chromatic[35]) / (chromatic[36] - chromatic[35]));
      //interpolate  phase target
      phasetarget = phasetargetset[11] + (phasetargetset[12] - phasetargetset[11]) *
                    ((drivefrequency - chromatic[35]) / (chromatic[36] - chromatic[35]));
      //interpolate  speaker gain
      speakergain = speakergainset[11] + (speakergainset[12] - speakergainset[11]) *
                    ((drivefrequency - chromatic[35]) / (chromatic[36] - chromatic[35]));
    }

    else if (drivefrequency <= chromatic[37]) //1245-1661
    {
      tuningband = 12;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[12] + (phasegainset[13] - phasegainset[12]) *
                  ((drivefrequency - chromatic[36]) / (chromatic[37] - chromatic[36]));
      //interpolate derivative gain
      derivativegain = derivativegainset[12] + (derivativegainset[13] - derivativegainset[12]) *
                       ((drivefrequency - chromatic[36]) / (chromatic[37] - chromatic[36]));
      //interpolate  phase target
      phasetarget = phasetargetset[12] + (phasetargetset[13] - phasetargetset[12]) *
                    ((drivefrequency - chromatic[36]) / (chromatic[37] - chromatic[36]));
      //interpolate  speaker gain
      speakergain = speakergainset[12] + (speakergainset[13] - speakergainset[12]) *
                    ((drivefrequency - chromatic[36]) / (chromatic[37] - chromatic[36]));
    }

    else if (drivefrequency <= chromatic[38]) //1245-1661
    {
      tuningband = 13;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[13] + (phasegainset[14] - phasegainset[13]) *
                  ((drivefrequency - chromatic[37]) / (chromatic[38] - chromatic[37]));
      //interpolate derivative gain
      derivativegain = derivativegainset[13] + (derivativegainset[14] - derivativegainset[13]) *
                       ((drivefrequency - chromatic[37]) / (chromatic[38] - chromatic[37]));
      //interpolate  phase target
      phasetarget = phasetargetset[13] + (phasetargetset[14] - phasetargetset[13]) *
                    ((drivefrequency - chromatic[37]) / (chromatic[38] - chromatic[37]));
      //interpolate  speaker gain
      speakergain = speakergainset[13] + (speakergainset[14] - speakergainset[13]) *
                    ((drivefrequency - chromatic[37]) / (chromatic[38] - chromatic[37]));
    }

    else if (drivefrequency <= chromatic[39]) //1245-1661
    {
      tuningband = 14;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[14] + (phasegainset[15] - phasegainset[14]) *
                  ((drivefrequency - chromatic[38]) / (chromatic[39] - chromatic[38]));
      //interpolate derivative gain
      derivativegain = derivativegainset[14] + (derivativegainset[15] - derivativegainset[14]) *
                       ((drivefrequency - chromatic[38]) / (chromatic[39] - chromatic[38]));
      //interpolate  phase target
      phasetarget = phasetargetset[14] + (phasetargetset[15] - phasetargetset[14]) *
                    ((drivefrequency - chromatic[38]) / (chromatic[39] - chromatic[38]));
      //interpolate  speaker gain
      speakergain = speakergainset[14] + (speakergainset[15] - speakergainset[14]) *
                    ((drivefrequency - chromatic[38]) / (chromatic[39] - chromatic[38]));
    }

    else if (drivefrequency <= chromatic[40]) //1245-1661
    {
      tuningband = 15;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[15] + (phasegainset[16] - phasegainset[15]) *
                  ((drivefrequency - chromatic[39]) / (chromatic[40] - chromatic[39]));
      //interpolate derivative gain
      derivativegain = derivativegainset[15] + (derivativegainset[16] - derivativegainset[15]) *
                       ((drivefrequency - chromatic[39]) / (chromatic[40] - chromatic[39]));
      //interpolate  phase target
      phasetarget = phasetargetset[15] + (phasetargetset[16] - phasetargetset[15]) *
                    ((drivefrequency - chromatic[39]) / (chromatic[40] - chromatic[39]));
      //interpolate  speaker gain
      speakergain = speakergainset[15] + (speakergainset[16] - speakergainset[15]) *
                    ((drivefrequency - chromatic[39]) / (chromatic[40] - chromatic[39]));
    }

    else if (drivefrequency <= chromatic[41]) //1245-1661
    {
      tuningband = 16;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[16] + (phasegainset[17] - phasegainset[16]) *
                  ((drivefrequency - chromatic[40]) / (chromatic[41] - chromatic[40]));
      //interpolate derivative gain
      derivativegain = derivativegainset[16] + (derivativegainset[17] - derivativegainset[16]) *
                       ((drivefrequency - chromatic[40]) / (chromatic[41] - chromatic[40]));
      //interpolate  phase target
      phasetarget = phasetargetset[16] + (phasetargetset[17] - phasetargetset[16]) *
                    ((drivefrequency - chromatic[40]) / (chromatic[41] - chromatic[40]));
      //interpolate  speaker gain
      speakergain = speakergainset[16] + (speakergainset[17] - speakergainset[16]) *
                    ((drivefrequency - chromatic[40]) / (chromatic[41] - chromatic[40]));
    }

    else if (drivefrequency <= chromatic[42]) //1245-1661
    {
      tuningband = 17;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[17] + (phasegainset[18] - phasegainset[17]) *
                  ((drivefrequency - chromatic[41]) / (chromatic[42] - chromatic[41]));
      //interpolate derivative gain
      derivativegain = derivativegainset[17] + (derivativegainset[18] - derivativegainset[17]) *
                       ((drivefrequency - chromatic[41]) / (chromatic[42] - chromatic[41]));
      //interpolate  phase target
      phasetarget = phasetargetset[17] + (phasetargetset[18] - phasetargetset[17]) *
                    ((drivefrequency - chromatic[41]) / (chromatic[42] - chromatic[41]));
      //interpolate  speaker gain
      speakergain = speakergainset[17] + (speakergainset[18] - speakergainset[17]) *
                    ((drivefrequency - chromatic[41]) / (chromatic[42] - chromatic[41]));
    }

    else if (drivefrequency <= chromatic[43]) //1245-1661
    {
      tuningband = 18;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[18] + (phasegainset[19] - phasegainset[18]) *
                  ((drivefrequency - chromatic[42]) / (chromatic[43] - chromatic[42]));
      //interpolate derivative gain
      derivativegain = derivativegainset[18] + (derivativegainset[19] - derivativegainset[18]) *
                       ((drivefrequency - chromatic[42]) / (chromatic[43] - chromatic[42]));
      //interpolate  phase target
      phasetarget = phasetargetset[18] + (phasetargetset[19] - phasetargetset[18]) *
                    ((drivefrequency - chromatic[42]) / (chromatic[43] - chromatic[42]));
      //interpolate  speaker gain
      speakergain = speakergainset[18] + (speakergainset[19] - speakergainset[18]) *
                    ((drivefrequency - chromatic[42]) / (chromatic[43] - chromatic[42]));
    }

    else if (drivefrequency <= chromatic[44]) //1245-1661
    {
      tuningband = 19;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[19] + (phasegainset[20] - phasegainset[19]) *
                  ((drivefrequency - chromatic[43]) / (chromatic[44] - chromatic[43]));
      //interpolate derivative gain
      derivativegain = derivativegainset[19] + (derivativegainset[20] - derivativegainset[19]) *
                       ((drivefrequency - chromatic[43]) / (chromatic[44] - chromatic[43]));
      //interpolate  phase target
      phasetarget = phasetargetset[19] + (phasetargetset[20] - phasetargetset[19]) *
                    ((drivefrequency - chromatic[43]) / (chromatic[44] - chromatic[43]));
      //interpolate  speaker gain
      speakergain = speakergainset[19] + (speakergainset[20] - speakergainset[19]) *
                    ((drivefrequency - chromatic[43]) / (chromatic[44] - chromatic[43]));
    }

    else if (drivefrequency <= chromatic[45]) //1245-1661
    {
      tuningband = 20;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[20] + (phasegainset[21] - phasegainset[20]) *
                  ((drivefrequency - chromatic[44]) / (chromatic[45] - chromatic[44]));
      //interpolate derivative gain
      derivativegain = derivativegainset[20] + (derivativegainset[21] - derivativegainset[20]) *
                       ((drivefrequency - chromatic[44]) / (chromatic[45] - chromatic[44]));
      //interpolate  phase target
      phasetarget = phasetargetset[20] + (phasetargetset[21] - phasetargetset[20]) *
                    ((drivefrequency - chromatic[44]) / (chromatic[45] - chromatic[44]));
      //interpolate  speaker gain
      speakergain = speakergainset[20] + (speakergainset[21] - speakergainset[20]) *
                    ((drivefrequency - chromatic[44]) / (chromatic[45] - chromatic[44]));
    }

    else if (drivefrequency <= chromatic[46]) //1245-1661
    {
      tuningband = 21;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[21] + (phasegainset[22] - phasegainset[21]) *
                  ((drivefrequency - chromatic[45]) / (chromatic[46] - chromatic[45]));
      //interpolate derivative gain
      derivativegain = derivativegainset[21] + (derivativegainset[22] - derivativegainset[21]) *
                       ((drivefrequency - chromatic[45]) / (chromatic[46] - chromatic[45]));
      //interpolate  phase target
      phasetarget = phasetargetset[21] + (phasetargetset[22] - phasetargetset[21]) *
                    ((drivefrequency - chromatic[45]) / (chromatic[46] - chromatic[45]));
      //interpolate  speaker gain
      speakergain = speakergainset[21] + (speakergainset[22] - speakergainset[21]) *
                    ((drivefrequency - chromatic[45]) / (chromatic[46] - chromatic[45]));
    }

    else if (drivefrequency <= chromatic[47]) //1245-1661
    {
      tuningband = 22;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[22] + (phasegainset[23] - phasegainset[22]) *
                  ((drivefrequency - chromatic[46]) / (chromatic[47] - chromatic[46]));
      //interpolate derivative gain
      derivativegain = derivativegainset[22] + (derivativegainset[23] - derivativegainset[22]) *
                       ((drivefrequency - chromatic[46]) / (chromatic[47] - chromatic[46]));
      //interpolate  phase target
      phasetarget = phasetargetset[22] + (phasetargetset[23] - phasetargetset[22]) *
                    ((drivefrequency - chromatic[46]) / (chromatic[47] - chromatic[46]));
      //interpolate  speaker gain
      speakergain = speakergainset[22] + (speakergainset[23] - speakergainset[22]) *
                    ((drivefrequency - chromatic[46]) / (chromatic[47] - chromatic[46]));
    }



    if (speakergain < 0)speakergain = 0;

    //    if (forceMode == 5)
    //    {
    //      derivativegainforced = map(whammyfrequency, 0, 255, 1, 100) / 10000;
    //      derivativegain = derivativegainforced;
    //    }

    //***********volume boost on rapid frequency change--could be more sophisticated, e.g continuous
    if (volumeboost == 1)
    {
      fderivative = (lastdrivefrequency - drivefrequency) * .1;//derivativegain; //looks at output derivative
      if ((fderivative) > 4) boost = .02;
      if (boost > 0) boost = boost - .001; //slow fall  to do reactivate with derivative gain
      speakergain = speakergain + boost;
    }
    //***************end of volume boost

    //**********************phasegain boost
    float flyingaverage = (drivefrequency + lastfrequency) / 2;
    slopemagnitude = ((drivefrequency - lastfrequency) / ((millis() - lastcheck) * flyingaverage));
    //slopemagnitude = abs(slopemagnitude);
    lastcheck = millis();
    lastfrequency = drivefrequency;
    //*************end of phasechange boost


    if (phasetarget < 0)phasetarget = 0;
    if (phasegain < 0)phasegain = 0;

    if (phasegainboost == 1)
    {
      if ((drivefrequency > 800) && ((slopemagnitude * 100000) < -400)) //
      {
        phasegain = phasegain + 3;
        gaincorrect = 100;
        boosttimeout = millis() + 25;
      }

      if ((drivefrequency <= 900) && ((slopemagnitude * 100000) > 400))
      {
        phasegain = phasegain + 3;
        gaincorrect = 100;
        boosttimeout = millis() + 25;
      }
    }


    if (boosttimeout > millis())
    {
      phasegain = phasegain + 3;
    }
    else gaincorrect = 0;

    /////////////////////////////////
    //calculate P and D error values
    /////////////////////////////////

    //    if (forceMode == 2) proportional = (phaseerror * phasegainforced);
    //    else proportional = (phaseerror * phasegain);
    proportional = (phaseerror * phasegain);

    //derivative = (lastdrivefrequency - drivefrequency) * derivativegain; //looks at output derivative
    //derivative = (previousphaseerror - phaseerror) * derivativegain;
    //should this be based on phaseerror(above)??
    //lastdrivefrequency = drivefrequency;
    previousphaseerror = phaseerror;

    /////////////////////////////////
    //adjust the drive frequency based on proportional and derivative
    /////////////////////////////////

    drivefrequency = drivefrequency - proportional - derivative; // derivative is negative to damp oscillation
    if (isnan(drivefrequency)) drivefrequency = 1200; //bug figure out later

    if (drivefrequency < BOTTOMFREQ) drivefrequency = BOTTOMFREQ;//prevents windup?
    if (drivefrequency > TOPFREQ) drivefrequency = TOPFREQ;

    //set global variable for ISR frequency control
    //if (DISPLAY_MODE == 2) drivefrequency = chromatic[scalefilter[AGCindex]]; //override for AGC adjust


    /////////////////////////////////
    //find closest note for LUT
    /////////////////////////////////

    driveerror = 9999;
    closestfrequency = 0;
    for (int x = 0;  x < 50; x++)
    {
      if (abs(chromatic[x] - drivefrequency) < driveerror)
      {
        driveerror = abs(chromatic[x] - drivefrequency);
        closestLUTnumber = x;
      }
    }

    //    whammyfrequency = analogRead(WhammyPin);
    //    if (forceMode == 0)
    //    {
    //      drivefrequencyforced = map(whammyfrequency, 0, 255, 393, 1400);
    //      drivefrequency = drivefrequencyforced;
    //    }
    //    if (forceMode == 1) phasetargetforced = map(whammyfrequency, 0, 255, 10, 40) / 100;
    //    if (forceMode == 2) phasegainforced = map(whammyfrequency, 0, 255, 1, 12);
    //    if (forceMode == 3) AGCsmoothforced = map(whammyfrequency, 0, 255, 1, 200) / 1000;


    sineincrement = (10000 / drivefrequency); //test for drivefreq change?
    /////////////////////////////////
    //find closest scale note for quantization
    /////////////////////////////////

    driveerror = 9999;
    closestfrequency = 0;
    for (int x = 0;  x < SCALESIZE; x++)
    {
      if (abs(chromatic[scalefilter[x]] - drivefrequency) < driveerror)
      {
        driveerror = abs(chromatic[scalefilter[x]] - drivefrequency);
        closestfrequency = chromatic[scalefilter[x]];
        closestscalenumber = x;

      }
    }

    /////////////////////////////////
    //recalculate closest scale note for hysteresis
    /////////////////////////////////

    hyster_closest_scale_number = closestscalenumber;
    float A = chromatic[scalefilter[hyster_closest_scale_number]];
    float B = chromatic[scalefilter[hyster_last_closest_scale_number]];
    newnote = false;
    if (A > B)
    {
      if (drivefrequency < ((A + B) / 2) + ((A - B) / hysteresisamount)) // 1/5 is the hysteramount
        hyster_closest_scale_number = hyster_last_closest_scale_number;
    }
    else if (B > A)
    {
      if (drivefrequency > ((A + B) / 2) - ((B - A) / hysteresisamount))
        hyster_closest_scale_number = hyster_last_closest_scale_number;
    }
    else newnote = true;

    hyster_last_closest_scale_number = hyster_closest_scale_number;
    //closest_chromatic_note_number = scalefilter[hyster_closest_scale_number];

    //    if (lasthysterclosestnote != hysterclosestnote) glide1.amplitude(hysterclosestnote / 20000, glide_rate);
    //    lasthysterclosestnote = hysterclosestnote;
    //    hysterclosestnote = chromatic[scalefilter[hyster_closest_scale_number]];





    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// BEGIN SYNTHEZIER MECHANICS/ UI
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////
    //sleep timer
    /////////////////////////////////////////

    //test sleep timer--turns off mouth speaker after a few seconds
    if ((sleeptimer < millis()) && (woken == true))
    {
      woken = false;  //go to sleep
      wokenstall = false;
    }

    //    if (((glide4.read() == 0)) && (alivetimer < millis())) //slow blink to show battery is on
    //    {
    //      alivetimer = millis() + 5000;
    //      analogWrite(redPin, 0);
    //      delay(1);
    //      analogWrite(redPin, 256);
    //    }

    //maintains sleep timer even if not transition of button
    if ((cherry1 == true)  || (cherry2 == true) || (cherry3 == true) )
    {
      sleeptimer = millis() + 5000;
      if (woken == false) wokentime = millis();
      woken = true;
    }

    if ((woken == true) && (wokentime + 500 < millis()) ) wokenstall = true; //don't make sound for 2 seconds after mouth spek

    /////////////////////////////////////////
    //synthesizer mode button detect/ binary encoding etc
    /////////////////////////////////////////

    if ((digitalRead(modePin) == 0) && (modebutton == false))
    {
      modebutton = true;
      modecount++;
      modeupdate = true;
      if (modecount > 9) modecount = 1; //
      //"***************************************************");
      Colorme(modecount);
      bouncetimer3 = millis() + 100;
      offtimer = millis() + 3000;
      woken = false;
      wokenstall = false;
      displayMode = 0;


    }
    else if (millis() > bouncetimer3)
    {
      if (digitalRead(modePin) == 1) modebutton = false;
    }






    //////////////////////////////////
    //CHANGE SYNTH MODE
    /////////////////////////////////

    if (modeupdate == true)
    {
      modeupdate = false;
      delay(300); //eeprom protect
      switch (modecount)
      {
        case 1:
          for (int x = 0; x < 150; x++) dynamic_byte_parameter[x] = float(preset_byte_parameter1[x]);
          break;
        case 2:
          for (int x = 0; x < 150; x++) dynamic_byte_parameter[x] = float(preset_byte_parameter2[x]);
          break;
        case 3:
          for (int x = 0; x < 150; x++) dynamic_byte_parameter[x] = float(preset_byte_parameter3[x]);
          break;
        case 4:
          for (int x = 0; x < 150; x++) dynamic_byte_parameter[x] = float(preset_byte_parameter4[x]);
          break;
        case 5:
          for (int x = 0; x < 150; x++) dynamic_byte_parameter[x] = float(preset_byte_parameter5[x]);
          break;
        case 6:
          if (EEPROM.read(0) != 0)for (int x = 0; x < 150; x++)dynamic_byte_parameter[x] = float(preset_byte_parameter6[x]);
          else for (int x = 0; x < 150; x++) dynamic_byte_parameter[x] = EEPROM.read(x + 1);
          break;
        case 7:
          if (EEPROM.read(251) != 0) for (int x = 0; x < 150; x++)dynamic_byte_parameter[x] = float(preset_byte_parameter7[x]);
          else for (int x = 0; x < 150; x++) dynamic_byte_parameter[x] = EEPROM.read(x + 152);
          break;
        case 8:
          if (EEPROM.read(501) != 0) for (int x = 0; x < 150; x++)dynamic_byte_parameter[x] = float(preset_byte_parameter8[x]);
          else for (int x = 0; x < 150; x++) dynamic_byte_parameter[x] = EEPROM.read(x + 302);
          break;
        case 9:
          if (EEPROM.read(751) != 0)for (int x = 0; x < 150; x++)
              dynamic_byte_parameter[x] = float(preset_byte_parameter9[x]);
          else for (int x = 0; x < 150; x++) dynamic_byte_parameter[x] = EEPROM.read(x + 452);
          break;
        default:
          //"no such mode");
          break;
      }
      Serial.println("0 " + String(modecount) + " "); //update preset display
      UpdateLocalVariables(); //updates local variables
      UpdateGUI(); //updates the controls from the local variables
    }


    /////////////////////////////////
    // SENSING CHERRY SWITCHES 1, 2, 3
    /////////////////////////////////

    //********first switch*********************************************
    if ((digitalRead(closeButton) == false) && (cherry1 == false) && (millis() > bouncetimerB1))
    {
      cherry1 = true;
      bouncetimerA1 = millis() + 50;

    }

    if ((digitalRead(closeButton) == true) && (cherry1 == true) && (millis() > bouncetimerA1))
    {
      cherry1 = false;
      bouncetimerB1 = millis() + 50;
    }

    //********second switch*********************************************
    if ((digitalRead(middleButton) == false) && (cherry2 == false) && (millis() > bouncetimerB2))
    {
      cherry2 = true;
      bouncetimerA2 = millis() + 50;
      //      if (displayMode == 4) //if in PPL tuning mode, this button captures setting
      //      {
      //        if (forceMode == 1)phasetargetset[tuningband] = phasetargetforced;
      //        if (forceMode == 2)phasegainset[tuningband] = phasegainforced;
      //        if (forceMode == 3)speakergainset[tuningband] = AGCsmoothforced;
      //      }
    }

    if ((digitalRead(middleButton) == true) && (cherry2 == true) && (millis() > bouncetimerA2))
    {
      cherry2 = false;
      bouncetimerB2 = millis() + 50;
    }

    //********third switch*********************************************
    if ((digitalRead(farButton) == false) && (cherry3 == false) && (millis() > bouncetimerB3))
    {
      cherry3 = true;
      bouncetimerA3 = millis() + 50;
    }

    if ((digitalRead(farButton) == true) && (cherry3 == true) && (millis() > bouncetimerA3))
    {
      cherry3 = false;
      bouncetimerB3 = millis() + 50;
    }

    //binary encoding  ***************************************************************************
    //****binary state 0********************************************************************************
    if ((cherry2 == false) && (cherry3 == false) && (binarystate != 0))
    {
      binarystatetoggle0 = true;
      binarystate = 0;
    }
    //****binary state 1********************************************************************************
    if ((cherry2 == false) && (cherry3 == true) && (binarystate != 1))
    {
      binarystatetoggle1 = true;
      binarystate = 1;
    }
    //****binary state 2********************************************************************************
    if ((cherry2 == true) && (cherry3 == false) && (binarystate != 2))
    {
      binarystatetoggle2 = true;
      binarystate = 2;
    }
    //****binary state 3********************************************************************************
    if ((cherry2 == true) && (cherry3 == true) && (binarystate != 3))
    {
      binarystatetoggle3 = true;
      binarystate = 3;
    }


    //binary decoding  end***************************************************************************


    //////////////////////////////////////////
    //RECEIVE DATA FROM PROCESSING GUI (encoded 151-300?)
    //////////////////////////////////////////

    //receive input from GUI
    // if there's any serial available, read it:
    while (Serial.available() > 0)
    {
      // look for the next valid integer in the incoming serial stream:
      category = Serial.parseInt();
      // do it again:
      fvalue = Serial.parseInt();
      if (Serial.available() > 0) Serial.read(); //flush --needed?
      // look for the newline. That's the end of the input:
      if ((fvalue != 1999) || (onetime == true))
      {
        integerinput[category] = fvalue;
        fvalue = 1999;
      }
      UpdateLocalVariables(); //update working variables and personality byte file
    }

    if (dotheeepromsave == true)
    {
      dotheeepromsave = false;
      switch (targetpreset)
      {
        case 1:
          for (int x = 1; x < 150; x++)EEPROM.write(x, dynamic_byte_parameter[x - 1]);
          EEPROM.write(0, 0);  //marks as holding data
          break;
        case 2:
          for (int x = 1; x < 150; x++) EEPROM.write(x + 151, dynamic_byte_parameter[x - 1]);
          EEPROM.write(151, 0);
          break;
        case 3:
          for (int x = 1; x < 150; x++) EEPROM.write(x + 301, dynamic_byte_parameter[x - 1]);
          EEPROM.write(301, 0);
          break;
        case 4:
          for (int x = 1; x < 150; x++) EEPROM.write(x + 451, dynamic_byte_parameter[x - 1]);
          EEPROM.write(451, 0);
          break;
      }
      targetpreset = 0;
      Serial.println("132 " + String(0) + " "); //reset  button
    }

    if (dothetuningsave == true)
    {
      dothetuningsave = false;
      for (int x = 1001; x < 1026; x++)EEPROM.write(x, byte(phasegainset[x - 1001]));
      for (int x = 1026; x < 1051; x++)EEPROM.write (x, byte(phasetargetset[x - 1026] * 100));
      for (int x = 1051; x < 1076; x++)EEPROM.write(x, byte(factoryspeakergainset[x - 1051] * 100));
      EEPROM.write(1077, 0);
      analogWrite(redPin, 256);//off
      analogWrite(bluePin, 256);
      analogWrite(greenPin, 156);
      delay(2000);//eeprom excessive write protection
      analogWrite(redPin, 256);//off
      analogWrite(bluePin, 256);
      analogWrite(greenPin, 256);
      Serial.println("218 " + String(0) + " "); //reset  button
    }

    if (dothefactoryreset == true)
    {
      dothefactoryreset = false;
      switch (targetpreset)
      {
        case 1:
          EEPROM.write(0, 0);  //marks as no storage in eeprom
          //          lastmodecount = 12; //auto move to that preset
          //          modecount = 6;
          break;
        case 2:
          EEPROM.write(151, 0);
          //          lastmodecount = 12;
          //          modecount = 7;
          break;
        case 3:
          EEPROM.write(301, 0);
          //          lastmodecount = 12;
          //          modecount = 8;
          break;
        case 4:
          EEPROM.write(451, 0);
          //          lastmodecount = 12;
          //          modecount = 9;
          break;//
      }
      delay(100);
      Serial.println("134 " + String(0) + " "); //reset save button
      UpdateLocalVariables(); //updates local variables !!
      UpdateGUI(); //updates the controls from the local variables
    }


    if (dothetuningsreset == true)//factory reset of phase
    {
      EEPROM.write(1077, 0);
      dothetuningsreset = false;
      for (int x = 0; x < 25; x++)dynamic_byte_parameter[x + 41] = factoryphasegainset[x];
      for (int x = 0; x < 25; x++)dynamic_byte_parameter[x + 71] = factoryphasetargetset[x] * 100;
      for (int x = 0; x < 25; x++)dynamic_byte_parameter[x + 101] = factoryspeakergainset[x] * 100;
      delay(2000);

      UpdateLocalVariables(); //updates local variables !!
      UpdateGUI(); //updates the controls from the local variables
      Serial.println("129 " + String(0) + " "); //reset save tunings button //$$
    }

    if (dotheGUIupdate == true)//for saving bytevalues
    {
      dotheGUIupdate = false; //offset these value to avoid conflicts???
      for (int x = 0; x < 150; x++)Serial.println(String(x + 155) + " " + String(dynamic_byte_parameter[x]) + " "); // send the byte values
      Serial.println("131 " + String(0) + " "); ////turn off save a file and trigger actual save
    }

    if (dotheautoscaleset == true)
    {
      dotheautoscaleset = false;
      switch (scaleNumber) {
        case 0:
          for (int x=0; x < 22; x++)dynamic_byte_parameter[x + 12] = scaletemplate1[x];
          break;
        case 1:
          for (int x=0; x < 22; x++)dynamic_byte_parameter[x + 12] = scaletemplate2[x];
          break;
        case 2:
          for (int x=0; x < 22; x++)dynamic_byte_parameter[x + 12] = scaletemplate3[x];
          break;
        case 3:
          for (int x=0; x < 22; x++)dynamic_byte_parameter[x + 12] = scaletemplate4[x];
          break;
        case 4:
          for (int x=0; x < 22; x++)dynamic_byte_parameter[x + 12] = scaletemplate5[x];
          break;
        case 5:
          for (int x=0; x < 22; x++)dynamic_byte_parameter[x + 12] = scaletemplate6[x];
          break;
        case 6:
          for (int x=0; x < 22; x++)dynamic_byte_parameter[x + 12] = scaletemplate7[x];
          break;
        case 7:
          for (int x=0; x < 22; x++)dynamic_byte_parameter[x + 12] = scaletemplate8[x];
          break;
        case 8:
          for (int x=0; x < 22; x++)dynamic_byte_parameter[x + 12] = scaletemplate9[x];
          break;
        case 9:
          for (int x=0; x < 22; x++)dynamic_byte_parameter[x + 12] = scaletemplate10[x];
          break;
        case 10:
          for (int x=0; x < 22; x++)dynamic_byte_parameter[x + 12] = scaletemplate11[x];
          break;
        case 11:
          for (int x=0; x < 22; x++)dynamic_byte_parameter[x + 12] = scaletemplate12[x];
          break;
        case 12:
          for (int x=0; x < 22; x++)dynamic_byte_parameter[x + 12] = scaletemplate13[x];
          break;
        default:
          // if nothing else matches, do the default
          // default is optional
          break;
      }
      UpdateLocalVariables(); //updates local variables !!
      UpdateGUI(); //updates the controls from the local variables
      delay(1000);
      Serial.println("135 " + String(0) + " ");
    }

    //////////////////////////////////////////////////////////
    // 0-SAX PLAY
    /////////////////////////////////////////////////////////

    stickoverride = true;

    //*****************************************************************************************
    //tuning utility, use with serial monitor
    //button one plays note, two and three adjust delay line length--copie values to preset when done
    //*****************************************************************************************
    const bool activateTuning = false; //activate utility for tuning model
    if (activateTuning == true)
    {
      int lowoctave = 12; //set to 12 to check low register, 0 for high register
      if ((cherry1 == true) &&  (button1toggle == false))
      {
        button1toggle = true;
        sticktimer = millis() + 500; //short time to allow player to slide into correct value
        dc1.amplitude(1, 100);
        dc2.amplitude(1, 3000);
        AudioNoInterrupts();
        sax1.setParamValue("tubeLength", tubelength[scalefilter[hyster_closest_scale_number] - lowoctave] + adj);
        AudioInterrupts();

      }
      if ((cherry1 == true) && ((sticktimer > millis()) || stickoverride)
          && (hyster_closest_scale_number != hysterpreviousplayednotenumber1))
      {
        AudioNoInterrupts();
        sax1.setParamValue("tubeLength", tubelength[scalefilter[hyster_closest_scale_number] - lowoctave] + adj);
        AudioInterrupts();
        hysterpreviousplayednotenumber1 = hyster_closest_scale_number;
      }

      if ((cherry1 == false) && (button1toggle == true))
      {
        dc1.amplitude(0, 200);
        dc2.amplitude(0, 10);
        button1toggle = false;
      }

      if ((cherry2 == true) &&  (button2toggle == false))
      {
        button2toggle = true;
        adj = adj + .001;
        sax1.setParamValue("tubeLength", tubelength[scalefilter[hyster_closest_scale_number] - lowoctave] + adj);
        Serial.print(chromatic[scalefilter[hyster_closest_scale_number] - lowoctave]);
        Serial.print("  tube length:");
        Serial.println(tubelength[scalefilter[hyster_closest_scale_number] - lowoctave] + adj, 4);
      }

      if ((cherry2 == false) && (button2toggle == true))
      {
        button2toggle = false;
      }

      if ((cherry3 == true) &&  (button3toggle == false))
      {
        button3toggle = true;
        adj = adj - .001;
        sax1.setParamValue("tubeLength", tubelength[scalefilter[hyster_closest_scale_number] - lowoctave] + adj);
        Serial.print(chromatic[scalefilter[hyster_closest_scale_number] - lowoctave ]);
        Serial.print("  tube length:");
        Serial.println(tubelength[scalefilter[hyster_closest_scale_number] - lowoctave] + adj, 4);
      }

      if ((cherry3 == false) && (button3toggle == true))
      {
        button3toggle = false;
      }

      if ((freqprint + 1000) < millis())
      {
        freqprint = millis();

        if (notefreq1.available() == true)
        {
          Serial.print(drivefrequency);
          Serial.print(" / ");
          Serial.print(scalefilter[hyster_closest_scale_number] - lowoctave);
          Serial.print(" / ");
          Serial.print(chromatic[scalefilter[hyster_closest_scale_number] - lowoctave ]);
          Serial.print(" notefreq ");
          Serial.print(notefreq1.read());
          Serial.print(" tubelength ");
          Serial.print(tubelength[scalefilter[hyster_closest_scale_number] - lowoctave] + adj, 4);
          Serial.println("");
          Serial.print("whammyvalue:");
          Serial.print (whammyvalue);
          Serial.print("  pressure:");
          Serial.println((pressure[scalefilter[hyster_closest_scale_number] - lowoctave]) *dc1.read() );
          //Serial.println(300+whammyvalue*1000);
        }
      }

      whammyvalue = analogRead(WhammyPin);
      whammyvalue = whammyvalue / 256;
      sax1.setParamValue("pressure", (pressure[scalefilter[hyster_closest_scale_number] - lowoctave] )*dc1.read());
      AudioNoInterrupts();
      sax1.setParamValue("lipsTension", .71);
      sax1.setParamValue("mute", .5);
      sax1.setParamValue("vibratoGain", dc2.read());
      //filter1.frequency(10 * chromatic[scalefilter[hyster_closest_scale_number]]); //autotracking
      AudioInterrupts();


    }

    //*****************************************************************************************
    //end of tuning activation
    //*****************************************************************************************


    //*****************************************************************************************
    //sax logic
    //*************************************************************************************
    if (activateTuning == false)
    {
      //  cherry 1 logic--this is normal sax breath**************************************************************
      if ((cherry1 == true) &&  (button1toggle == false))
      {
        button1toggle = true;
        sticktimer = millis() + 500; //short time to allow player to slide into correct value
        dc1.amplitude(1, 100);
        dc2.amplitude(1, 3000);
        AudioNoInterrupts();
        sax1.setParamValue("tubeLength", tubelength[scalefilter[hyster_closest_scale_number]] );
        AudioInterrupts();
        //dropOctave = false;

      }
      if ((cherry1 == true) && ((sticktimer > millis()) || stickoverride)
          && (hyster_closest_scale_number != hysterpreviousplayednotenumber1))
      {
        AudioNoInterrupts();
        sax1.setParamValue("tubeLength", tubelength[scalefilter[hyster_closest_scale_number]] );
        AudioInterrupts();
        hysterpreviousplayednotenumber1 = hyster_closest_scale_number;
      }

      if ((cherry1 == false) && (button1toggle == true))
      {
        dc1.amplitude(0, 200);
        dc2.amplitude(0, 10);
        button1toggle = false;
      }

      //  cherry 2 logic, burst sax breath for fast attack***************************************************************
      if ((cherry2 == true) &&  (button2toggle == false))
      {
        button2toggle = true;
        sticktimer = millis() + 500; //short time to allow player to slide into correct value
        dc1.amplitude(1, 100);
        dc2.amplitude(1, 3000);
        AudioNoInterrupts();
        sax1.setParamValue("tubeLength", tubelength[scalefilter[hyster_closest_scale_number]]);
        AudioInterrupts();
        //dropOctave = false;
      }

      if ((cherry2 == true) && ((sticktimer > millis()) || stickoverride)
          && (hyster_closest_scale_number != hysterpreviousplayednotenumber1))
      {
        AudioNoInterrupts();
        sax1.setParamValue("tubeLength", tubelength[scalefilter[hyster_closest_scale_number]] );
        AudioInterrupts();
        hysterpreviousplayednotenumber1 = hyster_closest_scale_number;
      }

      if ((cherry2 == false) && (button2toggle == true))
      {
        dc1.amplitude(0, 200);
        dc2.amplitude(0, 10);
        button2toggle = false;
        bumpcount = 0;
      }


      //  cherry 3 logic, burst sax breath for fast attack***************************************************************
      if ((cherry3 == true) &&  (button3toggle == false))
      {
        button3toggle = true;
        sticktimer = millis() + 500; //short time to allow player to slide into correct value
        dc1.amplitude(1, 100);
        dc2.amplitude(1, 3000);
        AudioNoInterrupts();
        sax1.setParamValue("tubeLength", tubelength[scalefilter[hyster_closest_scale_number]]);
        AudioInterrupts();
        bendtoggle = true;
        //dropOctave = false;
      }

      if ((cherry3 == true) && ((sticktimer > millis()) || stickoverride)
          && (hyster_closest_scale_number != hysterpreviousplayednotenumber1))
      {
        AudioNoInterrupts();
        sax1.setParamValue("tubeLength", tubelength[scalefilter[hyster_closest_scale_number]] );
        AudioInterrupts();
        hysterpreviousplayednotenumber1 = hyster_closest_scale_number;
      }

      if ((cherry3 == false) && (button3toggle == true))
      {
        dc1.amplitude(0, 200);
        dc2.amplitude(0, 10);
        button3toggle = false;
        bendcount = 0;
      }

      whammyvalue = analogRead(WhammyPin);
      whammyvalue = whammyvalue / 256;
      //whammyvalue = mapfloat(whammyvalue, 0, 1, .3, .8);


      //breath bump for sharp attack

      //      if ((dropOctave == false)&&(cherry2 == true))
      //      {
      //        sax1.setParamValue("pressure", pressure[scalefilter[hyster_closest_scale_number]] *dc1.read() + whammyvalue + bump);
      //      }
      //      else sax1.setParamValue("pressure", pressure[scalefilter[hyster_closest_scale_number] - 12] *dc1.read() + whammyvalue + bump);


      if (cherry2 == true)//bump the note
      {
        if ((offtime + 50 < millis()) && (bumptoggle == true) && (bumpcount < 2))
        {
          bump = 1;
          bumpcount++;
          bumptoggle = false;
          ontime = millis();
        }
        if ((ontime + 2 < millis()) && (bumptoggle == false))
        {
          bump = 0;
          bumptoggle = true;
          offtime = millis();
        }
      } else bump = 0;

      if (cherry3 == true)//bend the note
      {
        if ((offtime + 70 < millis()) && (bendtoggle == true) && (bendcount < 4))
        {
          bend = 3;
          bendcount++;
          bendtoggle = false;
          ontime = millis();
          Serial.println(bend);
        }
        if ((ontime + 20 < millis()) && (bendtoggle == false))
        {
          bend = 0;
          bendtoggle = true;
          offtime = millis();
          Serial.println(bend);
        }
      } else bend = 0;

      sax1.setParamValue("tubeLength", tubelength[scalefilter[hyster_closest_scale_number + bend]]);
      sax1.setParamValue("pressure", pressure[scalefilter[hyster_closest_scale_number]] *dc1.read() + whammyvalue + bump);

      AudioNoInterrupts();
      sax1.setParamValue("lipsTension", .71);//whammyvalue);
      sax1.setParamValue("mute", .5);
      sax1.setParamValue("vibratoGain", dc2.read());
      //filter1.frequency(10 * chromatic[scalefilter[hyster_closest_scale_number]]); //autotracking
      AudioInterrupts();

    }

    //*****************************************************************************************
    //end of sax logic
    //*************************************************************************************


    capture = false; //controls filling buffer
  }//end of capture==true
}//end of main *********************************************************************************************************


////////////////////////////////////////////////////
//     FUNCTIONS
///////////////////////////////////////////////////


void UpdateGUI(void)  //update the control graphics in Processing program in PC
//sent data needs to be an integer
{
  Serial.println("0 " + String(1) + " ");
  Serial.println("1 " + String(int(reverb_amount * 100)) + " ");
  Serial.println("2 " + String(int(reverb_size * 100)) + " ");
  Serial.println("3 " + String(int(reverb_damping * 100)) + " ");
  Serial.println("4 " + String(0) + " ");
  Serial.println("5 " + String(0) + " ");
  Serial.println("6 " + String(int(LPfilterRes * 100)) + " ");
  Serial.println("7 " + String(LPfilterFreq) + " ");
  Serial.println("8 " + String(int(HPfilterRes * 100)) + " ");
  Serial.println("9 " + String(HPfilterFreq) + " ");
  Serial.println("10 " + String(0) + " ");
  Serial.println("11 " + String(0) + " "); //
  Serial.println("12 " + String(noteA4) + " "); //
  Serial.println("13 " + String(noteAs4) + " "); //
  Serial.println("14 " + String(noteB4) + " "); //
  Serial.println("15 " + String(noteC5) + " "); //
  Serial.println("16 " + String(noteCs5) + " "); //
  Serial.println("17 " + String(noteD5) + " "); //
  Serial.println("18 " + String(noteDs5) + " "); //
  Serial.println("19 " + String(noteE5) + " "); //
  Serial.println("20 " + String(noteF5) + " "); //
  Serial.println("21 " + String(noteFs5) + " "); //
  Serial.println("22 " + String(noteG5) + " "); //
  Serial.println("23 " + String(noteGs5) + " "); //
  Serial.println("24 " + String(noteA5) + " "); //
  Serial.println("25 " + String(noteAs5) + " "); //
  Serial.println("26 " + String(noteB5) + " "); //
  Serial.println("27 " + String(noteC6) + " "); //
  Serial.println("28 " + String(noteCs6) + " "); //
  Serial.println("29 " + String(noteD6) + " "); //
  Serial.println("30 " + String(noteDs6) + " "); //
  Serial.println("31 " + String(noteE6) + " "); //
  Serial.println("32 " + String(noteF6) + " "); //
  Serial.println("33 " + String(noteFs6) + " "); //
  Serial.println("34 " + String(chordPreset) + " "); //
  Serial.println("35 " + String(0) + " "); //
  Serial.println("36 " + String(0) + " "); //
  //Serial.println("37 " + String(chordPreset) + " "); //
  Serial.println("38 " + String(presetLoad) + " "); //
  //Serial.println("39 " + String(factoryReset) + " "); //
  Serial.println("40 " + String(0) + " "); //
  Serial.println("41 " + String(phasegainset[0]) + " ");
  Serial.println("42 " + String(phasegainset[1]) + " ");
  Serial.println("43 " + String(phasegainset[2]) + " ");
  Serial.println("44 " + String(phasegainset[3]) + " ");
  Serial.println("45 " + String(phasegainset[4]) + " ");
  Serial.println("46 " + String(phasegainset[5]) + " ");
  Serial.println("47 " + String(phasegainset[6]) + " ");
  Serial.println("48 " + String(phasegainset[7]) + " ");
  Serial.println("49 " + String(phasegainset[8]) + " ");
  Serial.println("50 " + String(phasegainset[9]) + " ");
  Serial.println("51 " + String(phasegainset[10]) + " ");
  Serial.println("52 " + String(phasegainset[11]) + " ");
  Serial.println("53 " + String(phasegainset[12]) + " ");
  Serial.println("54 " + String(phasegainset[13]) + " ");
  Serial.println("55 " + String(phasegainset[14]) + " ");
  Serial.println("56 " + String(phasegainset[15]) + " ");
  Serial.println("57 " + String(phasegainset[16]) + " ");
  Serial.println("58 " + String(phasegainset[17]) + " ");
  Serial.println("59 " + String(phasegainset[18]) + " ");
  Serial.println("60 " + String(phasegainset[19]) + " ");
  Serial.println("61 " + String(phasegainset[20]) + " ");
  Serial.println("62 " + String(phasegainset[21]) + " ");
  Serial.println("63 " + String(phasegainset[22]) + " ");
  Serial.println("64 " + String(phasegainset[23]) + " ");
  Serial.println("65 " + String(phasegainset[24]) + " ");
  Serial.println("66 " + String(0) + " ");
  Serial.println("67 " + String(0) + " ");
  Serial.println("68 " + String(0) + " ");
  Serial.println("68 " + String(0) + " ");
  Serial.println("69 " + String(0) + " ");
  Serial.println("71 " + String(phasetargetset[0] * 100) + " ");
  Serial.println("72 " + String(phasetargetset[1] * 100) + " ");
  Serial.println("73 " + String(phasetargetset[2] * 100) + " ");
  Serial.println("74 " + String(phasetargetset[3] * 100) + " ");
  Serial.println("75 " + String(phasetargetset[4] * 100) + " ");
  Serial.println("76 " + String(phasetargetset[5] * 100) + " ");
  Serial.println("77 " + String(phasetargetset[6] * 100) + " ");
  Serial.println("78 " + String(phasetargetset[7] * 100) + " ");
  Serial.println("79 " + String(phasetargetset[8] * 100) + " ");
  Serial.println("80 " + String(phasetargetset[9] * 100) + " ");
  Serial.println("81 " + String(phasetargetset[10] * 100) + " ");
  Serial.println("82 " + String(phasetargetset[11] * 100) + " ");
  Serial.println("83 " + String(phasetargetset[12] * 100) + " ");
  Serial.println("84 " + String(phasetargetset[13] * 100) + " ");
  Serial.println("85 " + String(phasetargetset[14] * 100) + " ");
  Serial.println("86 " + String(phasetargetset[15] * 100) + " ");
  Serial.println("87 " + String(phasetargetset[16] * 100) + " ");
  Serial.println("88 " + String(phasetargetset[17] * 100) + " ");
  Serial.println("89 " + String(phasetargetset[18] * 100) + " ");
  Serial.println("90 " + String(phasetargetset[19] * 100) + " ");
  Serial.println("91 " + String(phasetargetset[20] * 100) + " ");
  Serial.println("92 " + String(phasetargetset[21] * 100) + " ");
  Serial.println("93 " + String(phasetargetset[22] * 100) + " ");
  Serial.println("94 " + String(phasetargetset[23] * 100) + " ");
  Serial.println("95 " + String(phasetargetset[24] * 100) + " ");
  Serial.println("96 " + String(0) + " ");
  Serial.println("97 " + String(0) + " ");
  Serial.println("98 " + String(0) + " ");
  Serial.println("99 " + String(0) + " ");
  Serial.println("100 " + String(0) + " ");
  Serial.println("101 " + String(speakergainset[0] * 100) + " ");
  Serial.println("102 " + String(speakergainset[1] * 100) + " ");
  Serial.println("103 " + String(speakergainset[2] * 100) + " ");
  Serial.println("104 " + String(speakergainset[3] * 100) + " ");
  Serial.println("105 " + String(speakergainset[4] * 100) + " ");
  Serial.println("106 " + String(speakergainset[5] * 100) + " ");
  Serial.println("107 " + String(speakergainset[6] * 100) + " ");
  Serial.println("108 " + String(speakergainset[7] * 100) + " ");
  Serial.println("119 " + String(speakergainset[8] * 100) + " ");
  Serial.println("110 " + String(speakergainset[9] * 100) + " ");
  Serial.println("111 " + String(speakergainset[10] * 100) + " ");
  Serial.println("112 " + String(speakergainset[11] * 100) + " ");
  Serial.println("113 " + String(speakergainset[12] * 100) + " ");
  Serial.println("114 " + String(speakergainset[13] * 100) + " ");
  Serial.println("115 " + String(speakergainset[14] * 100) + " ");
  Serial.println("116 " + String(speakergainset[15] * 100) + " ");
  Serial.println("117 " + String(speakergainset[16] * 100) + " ");
  Serial.println("118 " + String(speakergainset[17] * 100) + " ");
  Serial.println("119 " + String(speakergainset[18] * 100) + " ");
  Serial.println("120 " + String(speakergainset[19] * 100) + " ");
  Serial.println("121 " + String(speakergainset[20] * 100) + " ");
  Serial.println("122 " + String(speakergainset[21] * 100) + " ");
  Serial.println("123 " + String(speakergainset[22] * 100) + " ");
  Serial.println("124 " + String(speakergainset[23] * 100) + " ");
  Serial.println("125 " + String(speakergainset[24] * 100) + " ");
  Serial.println("126 " + String(0) + " ");
  Serial.println("127 " + String(0) + " ");
  Serial.println("128 " + String(0) + " ");
  //
  //  //this lines should be last to provide GUI with a full parameter list to save
  Serial.println("130 " + String(refreshcontrols) + " "); //$$
  //  //}
}




//FUNCTIONS

//////////////////////////////////////////////////////////
// COLORME FUNCTION  sets led color
/////////////////////////////////////////////////////////
void Colorme(int color)
{
  uncolor = millis();
  switch (color)
  {
    case 1:
      analogWrite(redPin, 256);//off
      analogWrite(bluePin, 256);
      analogWrite(greenPin, 256);
      break;
    case 2:
      analogWrite(redPin, 128);//red
      analogWrite(bluePin, 256);
      analogWrite(greenPin, 256);
      break;
    case 3:
      analogWrite(redPin, 64);//pink
      analogWrite(bluePin, 198);
      analogWrite(greenPin, 198);
      break;
    case 4:
      analogWrite(redPin, 64);//orange
      analogWrite(bluePin, 256);
      analogWrite(greenPin, 172);
      break;
    case 5:
      analogWrite(redPin, 256);//green
      analogWrite(bluePin, 256);
      analogWrite(greenPin, 128);
      break;
    case 6:
      analogWrite(redPin, 128);//yellow
      analogWrite(bluePin, 256);
      analogWrite(greenPin, 128);
      break;
    case 7:
      analogWrite(redPin, 256);//aqua
      analogWrite(bluePin, 128);
      analogWrite(greenPin, 128);
      break;
    case 8:
      analogWrite(redPin, 256);//blue
      analogWrite(bluePin, 128);
      analogWrite(greenPin, 256);
      break;
    case 9:
      analogWrite(redPin, 128);//violet
      analogWrite(bluePin, 128);
      analogWrite(greenPin, 256);
      break;
    case 10:
      analogWrite(redPin, 128); //white
      analogWrite(bluePin, 128);
      analogWrite(greenPin, 128);
      break;
    default:
      // if nothing else matches, do the default
      // default is optional
      break;
  }
}


//////////////////////////////////////////////////////////
// GRABDATA FUNCTION  ISR to buffer microphone samples for analysis
/////////////////////////////////////////////////////////
void grabdata()
{
  //unsigned long starttime = micros(); //for profiling

  //Sine wave output to mouth speaker
  unsigned long temptime = micros();  //figure out sine table lookup
  int tableindex = int((temptime - ISRlasttime) / sineincrement);
  if (tableindex >= 100) //rising edge is always
  {
    tableindex = 0;
    ISRlasttime = temptime;
  }

  monitorval = int(sinetable[tableindex] * monitorgain);
  AudioNoInterrupts();
  if (woken == true)analogWrite(monitorPin, monitorval);
  //if (forceMode == 3) driveval = int(sinetable[tableindex] * AGCsmoothforced);
  //else driveval = int(sinetable[tableindex] * speakergain); // grab new reading from drivewave
  driveval = int(sinetable[tableindex] * speakergain);
  if (woken == false) driveval = 0;
  analogWrite(mouthSpkrOutput, driveval);//output to speaker
  AudioInterrupts();

  //read mouth microphone
  if (capture == false) //do this only if new data needed
  {
    micval = analogRead(micInputPin);   // grab new reading from microphone
    micbuffer[h] = micval;
    if ((tableindex == 0) && (earliest == true) && (h > 4))
    {
      risingedge = h;
      earliest = false;
    }
    drivebuffer[h] = driveval; // put new data into buffer
    h++;
    if (h >= BUFSIZE)
    {
      h = 0;
      capture = true; //full data set complete
      earliest = true;
    }
  }
  //duration = int(micros() - starttime);
}


//////////////////////////////////////////
// UpdateLocalVariables function
//////////////////////////////////////////
void UpdateLocalVariables()
{
  AudioNoInterrupts();
  //"integerinput" is integer received from GUI
  //1) reverb_amount (0-100)
  if (category == 1)dynamic_byte_parameter[1] = map(integerinput[1], 0, 100, 0, 255);
  reverb_amount = float(map(dynamic_byte_parameter[1], 0, 255, 0, 100)) / 100;
  mixer2.gain(0, reverb_amount);
  mixer2.gain(1, (1.0 - reverb_amount));

  //2) reverb_size (0-100)
  if (category == 2)dynamic_byte_parameter[2] = map(integerinput[2], 0, 100, 0, 255);
  reverb_size = float(map(dynamic_byte_parameter[2], 0, 255, 0, 100)) / 100;

  //3) reverb_damping (0-100)
  if (category == 3)dynamic_byte_parameter[3] = map(integerinput[3], 0, 100, 0, 255);
  reverb_damping = float(map(dynamic_byte_parameter[3], 0, 255, 0, 100)) / 100;

  //6)   (0-100)
  if (category == 6)dynamic_byte_parameter[6] = map(integerinput[6], 0, 100, 0, 255);
  LPfilterRes = float(map(dynamic_byte_parameter[6], 0, 255, 0, 100)) / 100;
  filter1.resonance(LPfilterRes);

  //7) LPfilterFreq (0-10000)
  if (category == 7)dynamic_byte_parameter[7] = map(integerinput[7], 0, 10000, 0, 255);
  LPfilterFreq = map(dynamic_byte_parameter[7], 0, 255, 0, 10000);
  filter1.frequency(LPfilterFreq);

  //8) HPfilterRes (0-100)
  if (category == 8)dynamic_byte_parameter[8] = map(integerinput[8], 0, 100, 0, 255);
  HPfilterRes = float(map(dynamic_byte_parameter[8], 0, 255, 0, 100)) / 100;
  filter2.resonance(HPfilterRes);

  //9) HPfilterFreq (0-10000)
  if (category == 9)dynamic_byte_parameter[9] = map(integerinput[9], 0, 10000, 0, 255);
  HPfilterFreq = map(dynamic_byte_parameter[9], 0, 255, 0, 10000);
  filter2.frequency(HPfilterFreq);

  //12) scale notes active (0-1)
  if (category == 12)dynamic_byte_parameter[12] = map(integerinput[12], 0, 255, 0, 255);
  if (dynamic_byte_parameter[12] > 1)dynamic_byte_parameter[12] = 1;
  noteA4 = map(dynamic_byte_parameter[12], 0, 255, 0, 255);
  if (noteA4 == 1)openfilter[26 - 20] = 26; else openfilter[26 - 20] = 0;

  //13) scale notes active (0-1)
  if (category == 13)dynamic_byte_parameter[13] = map(integerinput[13], 0, 255, 0, 255);
  if (dynamic_byte_parameter[13] > 1)dynamic_byte_parameter[13] = 1;
  noteAs4 = map(dynamic_byte_parameter[13], 0, 255, 0, 255);
  if (noteAs4 == 1)openfilter[27 - 20] = 27; else openfilter[27 - 20] = 0;

  //14) scale notes active (0-1)
  if (category == 14)dynamic_byte_parameter[14] = map(integerinput[14], 0, 255, 0, 255);
  if (dynamic_byte_parameter[14] > 1)dynamic_byte_parameter[14] = 1;
  noteB4 = map(dynamic_byte_parameter[14], 0, 255, 0, 255);
  if (noteB4 == 1)openfilter[28 - 20] = 28; else openfilter[28 - 20] = 0;

  //15) scale notes active (0-1)
  if (category == 15)dynamic_byte_parameter[15] = map(integerinput[15], 0, 255, 0, 255);
  if (dynamic_byte_parameter[15] > 1)dynamic_byte_parameter[15] = 1;
  noteC5 = map(dynamic_byte_parameter[15], 0, 255, 0, 255);
  if (noteC5 == 1)openfilter[29 - 20] = 29; else openfilter[29 - 20] = 0;

  //16) scale notes active (0-1)
  if (category == 16)dynamic_byte_parameter[16] = map(integerinput[16], 0, 255, 0, 255);
  if (dynamic_byte_parameter[16] > 1)dynamic_byte_parameter[16] = 1;
  noteCs5 = map(dynamic_byte_parameter[16], 0, 255, 0, 255);
  if (noteCs5 == 1)openfilter[30 - 20] = 30; else openfilter[30 - 20] = 0;

  //17) scale notes active (0-1)
  if (category == 17)dynamic_byte_parameter[17] = map(integerinput[17], 0, 255, 0, 255);
  if (dynamic_byte_parameter[17] > 1)dynamic_byte_parameter[17] = 1;
  noteD5 = map(dynamic_byte_parameter[17], 0, 255, 0, 255);
  if (noteD5 == 1)openfilter[31 - 20] = 31; else openfilter[31 - 20] = 0;

  //18) scale notes active (0-1)
  if (category == 18)dynamic_byte_parameter[18] = map(integerinput[18], 0, 255, 0, 255);
  if (dynamic_byte_parameter[18] > 1)dynamic_byte_parameter[18] = 1;
  noteDs5 = map(dynamic_byte_parameter[18], 0, 255, 0, 255);
  if (noteDs5 == 1)openfilter[32 - 20] = 32; else openfilter[32 - 20] = 0;

  //19) scale notes active (0-1)
  if (category == 19)dynamic_byte_parameter[19] = map(integerinput[19], 0, 255, 0, 255);
  if (dynamic_byte_parameter[19] > 1)dynamic_byte_parameter[19] = 1;
  noteE5 = map(dynamic_byte_parameter[19], 0, 255, 0, 255);
  if (noteE5 == 1)openfilter[33 - 20] = 33; else openfilter[33 - 20] = 0;

  //20) scale notes active (0-1)
  if (category == 20)dynamic_byte_parameter[20] = map(integerinput[20], 0, 255, 0, 255);
  if (dynamic_byte_parameter[20] > 1)dynamic_byte_parameter[20] = 1;
  noteF5 = map(dynamic_byte_parameter[20], 0, 255, 0, 255);
  if (noteF5 == 1)openfilter[34 - 20] = 34; else openfilter[34 - 20] = 0;

  //21) scale notes active (0-1)
  if (category == 21)dynamic_byte_parameter[21] = map(integerinput[21], 0, 255, 0, 255);
  if (dynamic_byte_parameter[21] > 1)dynamic_byte_parameter[21] = 1;
  noteFs5 = map(dynamic_byte_parameter[21], 0, 255, 0, 255);
  if (noteFs5 == 1)openfilter[35 - 20] = 35; else openfilter[35 - 20] = 0;

  //22) scale notes active (0-1)
  if (category == 22)dynamic_byte_parameter[22] = map(integerinput[22], 0, 255, 0, 255);
  if (dynamic_byte_parameter[22] > 1)dynamic_byte_parameter[12] = 1;
  noteG5 = map(dynamic_byte_parameter[22], 0, 255, 0, 255);
  if (noteG5 == 1)openfilter[36 - 20] = 36; else openfilter[36 - 20] = 0;

  //23) scale notes active (0-1)
  if (category == 23)dynamic_byte_parameter[23] = map(integerinput[23], 0, 255, 0, 255);
  if (dynamic_byte_parameter[23] > 1)dynamic_byte_parameter[23] = 1;
  noteGs5 = map(dynamic_byte_parameter[23], 0, 255, 0, 255);
  if (noteGs5 == 1)openfilter[37 - 20] = 37; else openfilter[37 - 20] = 0;

  //24) scale notes active (0-1)
  if (category == 24)dynamic_byte_parameter[24] = map(integerinput[24], 0, 255, 0, 255);
  if (dynamic_byte_parameter[24] > 1)dynamic_byte_parameter[24] = 1;
  noteA5 = map(dynamic_byte_parameter[24], 0, 255, 0, 255);
  if (noteA5 == 1)openfilter[38 - 20] = 38; else openfilter[38 - 20] = 0;

  //25) scale notes active (0-1)
  if (category == 25)dynamic_byte_parameter[25] = map(integerinput[25], 0, 255, 0, 255);
  if (dynamic_byte_parameter[25] > 1)dynamic_byte_parameter[25] = 1;
  noteAs5 = map(dynamic_byte_parameter[25], 0, 255, 0, 255);
  if (noteAs5 == 1)openfilter[39 - 20] = 39; else openfilter[39 - 20] = 0;

  //26) scale notes active (0-1)
  if (category == 26)dynamic_byte_parameter[26] = map(integerinput[26], 0, 255, 0, 255);
  if (dynamic_byte_parameter[26] > 1)dynamic_byte_parameter[26] = 1;
  noteB5 = map(dynamic_byte_parameter[26], 0, 255, 0, 255);
  if (noteB5 == 1)openfilter[40 - 20] = 40; else openfilter[40 - 20] = 0;

  //27) scale notes active (0-1)
  if (category == 27)dynamic_byte_parameter[27] = map(integerinput[27], 0, 255, 0, 255);
  if (dynamic_byte_parameter[27] > 1)dynamic_byte_parameter[27] = 1;
  noteC6 = map(dynamic_byte_parameter[27], 0, 255, 0, 255);
  if (noteC6 == 1)openfilter[41 - 20] = 41; else openfilter[41 - 20] = 0;

  //28) scale notes active (0-1)
  if (category == 28)dynamic_byte_parameter[28] = map(integerinput[28], 0, 255, 0, 255);
  if (dynamic_byte_parameter[28] > 1)dynamic_byte_parameter[28] = 1;
  noteCs6 = map(dynamic_byte_parameter[28], 0, 255, 0, 255);
  if (noteCs6 == 1)openfilter[42 - 20] = 42; else openfilter[42 - 20] = 0;

  //29) scale notes active (0-1)
  if (category == 29)dynamic_byte_parameter[29] = map(integerinput[29], 0, 255, 0, 255);
  if (dynamic_byte_parameter[29] > 1)dynamic_byte_parameter[29] = 1;
  noteD6 = map(dynamic_byte_parameter[29], 0, 255, 0, 255);
  if (noteD6 == 1)openfilter[43 - 20] = 43; else openfilter[43 - 20] = 0;

  //30) scale notes active (0-1)
  if (category == 30)dynamic_byte_parameter[30] = map(integerinput[30], 0, 255, 0, 255);
  if (dynamic_byte_parameter[30] > 1)dynamic_byte_parameter[30] = 1;
  noteDs6 = map(dynamic_byte_parameter[30], 0, 255, 0, 255);
  if (noteDs6 == 1)openfilter[44 - 20] = 44; else openfilter[44 - 20] = 0;

  //31) scale notes active (0-1)
  if (category == 31)dynamic_byte_parameter[31] = map(integerinput[31], 0, 255, 0, 255);
  if (dynamic_byte_parameter[31] > 1)dynamic_byte_parameter[12] = 1;
  noteE6 = map(dynamic_byte_parameter[31], 0, 255, 0, 255);
  if (noteE6 == 1)openfilter[45 - 20] = 45; else openfilter[45 - 20] = 0;

  //32) scale notes active (0-1)
  if (category == 32)dynamic_byte_parameter[32] = map(integerinput[32], 0, 255, 0, 255);
  if (dynamic_byte_parameter[32] > 1)dynamic_byte_parameter[32] = 1;
  noteF6 = map(dynamic_byte_parameter[32], 0, 255, 0, 255);
  if (noteF6 == 1)openfilter[46 - 20] = 46; else openfilter[46 - 20] = 0;

  //33) scale notes active (0-1)
  if (category == 33)dynamic_byte_parameter[33] = map(integerinput[33], 0, 255, 0, 255);
  if (dynamic_byte_parameter[33] > 1)dynamic_byte_parameter[33] = 1;
  noteFs6 = map(dynamic_byte_parameter[33], 0, 255, 0, 255);
  if (noteFs6 == 1)openfilter[47 - 20] = 47; else openfilter[47 - 20] = 0;

  //36) generate scale button (0-1)//?????
  if (category == 36)dynamic_byte_parameter[36] = map(integerinput[36], 0, 255, 0, 255);
  if (dynamic_byte_parameter[36] > 1)dynamic_byte_parameter[36] = 1;
  chordPreset = map(dynamic_byte_parameter[36], 0, 255, 0, 255);


  //37) load data from disk (0-1)
  if (category == 37)dynamic_byte_parameter[37] = map(integerinput[37], 0, 255, 0, 255);
  if (dynamic_byte_parameter[37] > 1)dynamic_byte_parameter[37] = 1;
  presetLoad = map(dynamic_byte_parameter[37], 0, 255, 0, 255);


  //38) save  settings to disk (0-1)
  if (category == 38)dynamic_byte_parameter[38] = map(integerinput[38], 0, 255, 0, 255);
  if (dynamic_byte_parameter[38] > 1)dynamic_byte_parameter[38] = 1;
  //savePhase = map(dynamic_byte_parameter[38], 0, 255, 0, 255);


  //39) factory reset flute(0-1)
  if (category == 39)dynamic_byte_parameter[39] = map(integerinput[39], 0, 255, 0, 255);
  if (dynamic_byte_parameter[39] > 1)dynamic_byte_parameter[39] = 1;
  //factoryReset = map(dynamic_byte_parameter[39], 0, 255, 0, 255);


  //40) save GUI settings to flute (0-1)
  if (category == 39)dynamic_byte_parameter[39] = map(integerinput[39], 0, 255, 0, 255);
  if (dynamic_byte_parameter[39] > 1)dynamic_byte_parameter[39] = 1;
  //factoryReset = map(dynamic_byte_parameter[39], 0, 255, 0, 255);


  //PPL variables

  if (category == 41)dynamic_byte_parameter[41] = map(integerinput[41], 0, 255, 0, 255);
  phasegainset[0] = map(dynamic_byte_parameter[41], 0, 255, 0, 255);

  if (category == 42)dynamic_byte_parameter[42] = map(integerinput[42], 0, 255, 0, 255);
  phasegainset[1] = map(dynamic_byte_parameter[42], 0, 255, 0, 255);


  if (category == 43)dynamic_byte_parameter[43] = map(integerinput[43], 0, 255, 0, 255);
  phasegainset[2] = map(dynamic_byte_parameter[43], 0, 255, 0, 255);


  if (category == 44)dynamic_byte_parameter[44] = map(integerinput[44], 0, 255, 0, 255);
  phasegainset[3] = map(dynamic_byte_parameter[44], 0, 255, 0, 255);


  if (category == 45)dynamic_byte_parameter[45] = map(integerinput[45], 0, 255, 0, 255);
  phasegainset[4] = map(dynamic_byte_parameter[45], 0, 255, 0, 255);


  if (category == 46)dynamic_byte_parameter[46] = map(integerinput[46], 0, 255, 0, 255);
  phasegainset[5] = map(dynamic_byte_parameter[46], 0, 255, 0, 255);


  if (category == 47)dynamic_byte_parameter[47] = map(integerinput[47], 0, 255, 0, 255);
  phasegainset[6] = map(dynamic_byte_parameter[47], 0, 255, 0, 255);


  if (category == 48)dynamic_byte_parameter[48] = map(integerinput[48], 0, 255, 0, 255);
  phasegainset[7] = map(dynamic_byte_parameter[48], 0, 255, 0, 255);

  if (category == 49)dynamic_byte_parameter[50] = map(integerinput[50], 0, 255, 0, 255);
  phasegainset[8] = map(dynamic_byte_parameter[50], 0, 255, 0, 255);


  if (category == 50)dynamic_byte_parameter[50] = map(integerinput[50], 0, 255, 0, 255);
  phasegainset[9] = map(dynamic_byte_parameter[50], 0, 255, 0, 255);


  if (category == 51)dynamic_byte_parameter[51] = map(integerinput[51], 0, 255, 0, 255);
  phasegainset[10] = map(dynamic_byte_parameter[51], 0, 255, 0, 255);


  if (category == 52)dynamic_byte_parameter[52] = map(integerinput[52], 0, 255, 0, 255);
  phasegainset[11] = map(dynamic_byte_parameter[52], 0, 255, 0, 255);


  if (category == 53)dynamic_byte_parameter[53] = map(integerinput[53], 0, 255, 0, 255);
  phasegainset[12] = map(dynamic_byte_parameter[53], 0, 255, 0, 255);


  if (category == 54)dynamic_byte_parameter[54] = map(integerinput[54], 0, 255, 0, 255);
  phasegainset[13] = map(dynamic_byte_parameter[54], 0, 255, 0, 255);


  if (category == 55)dynamic_byte_parameter[55] = map(integerinput[55], 0, 255, 0, 255);
  phasegainset[14] = map(dynamic_byte_parameter[55], 0, 255, 0, 255);


  if (category == 56)dynamic_byte_parameter[56] = map(integerinput[56], 0, 255, 0, 255);
  phasegainset[15] = map(dynamic_byte_parameter[56], 0, 255, 0, 255);


  if (category == 57)dynamic_byte_parameter[57] = map(integerinput[57], 0, 255, 0, 255);
  phasegainset[16] = map(dynamic_byte_parameter[57], 0, 255, 0, 255);


  if (category == 58)dynamic_byte_parameter[58] = map(integerinput[58], 0, 255, 0, 255);
  phasegainset[17] = map(dynamic_byte_parameter[58], 0, 255, 0, 255);


  if (category == 59)dynamic_byte_parameter[59] = map(integerinput[59], 0, 255, 0, 255);
  phasegainset[18] = map(dynamic_byte_parameter[59], 0, 255, 0, 255);


  if (category == 60)dynamic_byte_parameter[60] = map(integerinput[60], 0, 255, 0, 255);
  phasegainset[19] = map(dynamic_byte_parameter[60], 0, 255, 0, 255);


  if (category == 61)dynamic_byte_parameter[61] = map(integerinput[61], 0, 255, 0, 255);
  phasegainset[20] = map(dynamic_byte_parameter[61], 0, 255, 0, 255);


  if (category == 62)dynamic_byte_parameter[62] = map(integerinput[62], 0, 255, 0, 255);
  phasegainset[21] = map(dynamic_byte_parameter[62], 0, 255, 0, 255);


  if (category == 63)dynamic_byte_parameter[63] = map(integerinput[63], 0, 255, 0, 255);
  phasegainset[22] = map(dynamic_byte_parameter[63], 0, 255, 0, 255);


  if (category == 64)dynamic_byte_parameter[64] = map(integerinput[64], 0, 255, 0, 255);
  phasegainset[23] = map(dynamic_byte_parameter[64], 0, 255, 0, 255);


  if (category == 65)dynamic_byte_parameter[65] = map(integerinput[65], 0, 255, 0, 255);
  phasegainset[24] = map(dynamic_byte_parameter[65], 0, 255, 0, 255);


  if (category == 71)dynamic_byte_parameter[71] = map(integerinput[71], 0, 255, 0, 255);
  phasetargetset[0] = float(dynamic_byte_parameter[71]) / 100;

  if (category == 72)dynamic_byte_parameter[72] = map(integerinput[72], 0, 255, 0, 255);
  phasetargetset[1] = float(dynamic_byte_parameter[72]) / 100;

  if (category == 73)dynamic_byte_parameter[73] = map(integerinput[73], 0, 255, 0, 255);
  phasetargetset[2] = float(dynamic_byte_parameter[73]) / 100;


  if (category == 74)dynamic_byte_parameter[74] = map(integerinput[74], 0, 255, 0, 255);
  phasetargetset[3] = float(dynamic_byte_parameter[74]) / 100;

  if (category == 75)dynamic_byte_parameter[75] = map(integerinput[75], 0, 255, 0, 255);
  phasetargetset[4] = float(dynamic_byte_parameter[75]) / 100;

  if (category == 76)dynamic_byte_parameter[76] = map(integerinput[76], 0, 255, 0, 255);
  phasetargetset[5] = float(dynamic_byte_parameter[76]) / 100;

  if (category == 77)dynamic_byte_parameter[77] = map(integerinput[77], 0, 255, 0, 255);
  phasetargetset[6] = float(dynamic_byte_parameter[77]) / 100;

  if (category == 78)dynamic_byte_parameter[78] = map(integerinput[78], 0, 255, 0, 255);
  phasetargetset[7] = float(dynamic_byte_parameter[78]) / 100;

  if (category == 79)dynamic_byte_parameter[79] = map(integerinput[79], 0, 255, 0, 255);
  phasetargetset[8] = float(dynamic_byte_parameter[79]) / 100;

  if (category == 80)dynamic_byte_parameter[80] = map(integerinput[80], 0, 255, 0, 255);
  phasetargetset[9] = float(dynamic_byte_parameter[80]) / 100;

  if (category == 81)dynamic_byte_parameter[81] = map(integerinput[81], 0, 255, 0, 255);
  phasetargetset[10] = float(dynamic_byte_parameter[81]) / 100;

  if (category == 82)dynamic_byte_parameter[82] = map(integerinput[82], 0, 255, 0, 255);
  phasetargetset[11] = float(dynamic_byte_parameter[82]) / 100;

  if (category == 83)dynamic_byte_parameter[83] = map(integerinput[83], 0, 255, 0, 255);
  phasetargetset[12] = float(dynamic_byte_parameter[83]) / 100;

  if (category == 84)dynamic_byte_parameter[84] = map(integerinput[84], 0, 255, 0, 255);
  phasetargetset[13] = float(dynamic_byte_parameter[84]) / 100;

  if (category == 85)dynamic_byte_parameter[85] = map(integerinput[85], 0, 255, 0, 255);
  phasetargetset[14] = float(dynamic_byte_parameter[85]) / 100;

  if (category == 86)dynamic_byte_parameter[86] = map(integerinput[86], 0, 255, 0, 255);
  phasetargetset[15] = float(dynamic_byte_parameter[86]) / 100;

  if (category == 87)dynamic_byte_parameter[87] = map(integerinput[87], 0, 255, 0, 255);
  phasetargetset[16] = float(dynamic_byte_parameter[87]) / 100;

  if (category == 88 )dynamic_byte_parameter[88] = map(integerinput[88], 0, 255, 0, 255);
  phasetargetset[17] = float(dynamic_byte_parameter[88]) / 100;

  if (category == 89)dynamic_byte_parameter[89] = map(integerinput[89], 0, 255, 0, 255);
  phasetargetset[18] = float(dynamic_byte_parameter[89]) / 100;

  if (category == 90)dynamic_byte_parameter[90] = map(integerinput[90], 0, 255, 0, 255);
  phasetargetset[19] = float(dynamic_byte_parameter[90]) / 100;

  if (category == 91)dynamic_byte_parameter[91] = map(integerinput[91], 0, 255, 0, 255);
  phasetargetset[20] = float(dynamic_byte_parameter[91]) / 100;

  if (category == 92)dynamic_byte_parameter[92] = map(integerinput[92], 0, 255, 0, 255);
  phasetargetset[21] = float(dynamic_byte_parameter[92]) / 100;

  if (category == 93 )dynamic_byte_parameter[93] = map(integerinput[93], 0, 255, 0, 255);
  phasetargetset[22] = float(dynamic_byte_parameter[93]) / 100;

  if (category == 94)dynamic_byte_parameter[94] = map(integerinput[94], 0, 255, 0, 255);
  phasetargetset[23] = float(dynamic_byte_parameter[94]) / 100;

  if (category == 95)dynamic_byte_parameter[95] = map(integerinput[95], 0, 255, 0, 255);
  phasetargetset[24] = float(dynamic_byte_parameter[95]) / 100;






  if (category == 101)dynamic_byte_parameter[101] = map(integerinput[101], 0, 255, 0, 255);
  speakergainset[0] = float(dynamic_byte_parameter[101]) / 100;

  if (category == 102)dynamic_byte_parameter[102] = map(integerinput[102], 0, 255, 0, 255);
  speakergainset[1] = float(dynamic_byte_parameter[102]) / 100;

  if (category == 103)dynamic_byte_parameter[103] = map(integerinput[103], 0, 255, 0, 255);
  speakergainset[2] = float(dynamic_byte_parameter[103]) / 100;


  if (category == 104)dynamic_byte_parameter[104] = map(integerinput[104], 0, 255, 0, 255);
  speakergainset[3] = float(dynamic_byte_parameter[104]) / 100;

  if (category == 105)dynamic_byte_parameter[105] = map(integerinput[105], 0, 255, 0, 255);
  speakergainset[4] = float(dynamic_byte_parameter[105]) / 100;

  if (category == 106)dynamic_byte_parameter[106] = map(integerinput[106], 0, 255, 0, 255);
  speakergainset[5] = float(dynamic_byte_parameter[106]) / 100;

  if (category == 107)dynamic_byte_parameter[107] = map(integerinput[107], 0, 255, 0, 255);
  speakergainset[6] = float(dynamic_byte_parameter[107]) / 100;

  if (category == 108)dynamic_byte_parameter[108] = map(integerinput[108], 0, 255, 0, 255);
  speakergainset[7] = float(dynamic_byte_parameter[108]) / 100;

  if (category == 109)dynamic_byte_parameter[109] = map(integerinput[109], 0, 255, 0, 255);
  speakergainset[8] = float(dynamic_byte_parameter[109]) / 100;

  if (category == 110)dynamic_byte_parameter[110] = map(integerinput[110], 0, 255, 0, 255);
  speakergainset[9] = float(dynamic_byte_parameter[110]) / 100;

  if (category == 111)dynamic_byte_parameter[111] = map(integerinput[111], 0, 255, 0, 255);
  speakergainset[10] = float(dynamic_byte_parameter[111]) / 100;

  if (category == 112)dynamic_byte_parameter[112] = map(integerinput[112], 0, 255, 0, 255);
  speakergainset[11] = float(dynamic_byte_parameter[112]) / 100;

  if (category == 113)dynamic_byte_parameter[113] = map(integerinput[113], 0, 255, 0, 255);
  speakergainset[12] = float(dynamic_byte_parameter[113]) / 100;

  if (category == 114)dynamic_byte_parameter[114] = map(integerinput[114], 0, 255, 0, 255);
  speakergainset[13] = float(dynamic_byte_parameter[114]) / 100;

  if (category == 115)dynamic_byte_parameter[115] = map(integerinput[115], 0, 255, 0, 255);
  speakergainset[14] = float(dynamic_byte_parameter[115]) / 100;

  if (category == 116)dynamic_byte_parameter[116] = map(integerinput[116], 0, 255, 0, 255);
  speakergainset[15] = float(dynamic_byte_parameter[116]) / 100;

  if (category == 117)dynamic_byte_parameter[117] = map(integerinput[117], 0, 255, 0, 255);
  speakergainset[16] = float(dynamic_byte_parameter[117]) / 100;

  if (category == 118 )dynamic_byte_parameter[118] = map(integerinput[118], 0, 255, 0, 255);
  speakergainset[17] = float(dynamic_byte_parameter[118]) / 100;

  if (category == 119)dynamic_byte_parameter[119] = map(integerinput[119], 0, 255, 0, 255);
  speakergainset[18] = float(dynamic_byte_parameter[119]) / 100;

  if (category == 120)dynamic_byte_parameter[120] = map(integerinput[120], 0, 255, 0, 255);
  speakergainset[19] = float(dynamic_byte_parameter[120]) / 100;

  if (category == 121)dynamic_byte_parameter[121] = map(integerinput[121], 0, 255, 0, 255);
  speakergainset[20] = float(dynamic_byte_parameter[121]) / 100;

  if (category == 122)dynamic_byte_parameter[122] = map(integerinput[122], 0, 255, 0, 255);
  speakergainset[21] = float(dynamic_byte_parameter[122]) / 100;

  if (category == 123 )dynamic_byte_parameter[123] = map(integerinput[123], 0, 255, 0, 255);
  speakergainset[22] = float(dynamic_byte_parameter[123]) / 100;

  if (category == 124)dynamic_byte_parameter[124] = map(integerinput[124], 0, 255, 0, 255);
  speakergainset[23] = float(dynamic_byte_parameter[124]) / 100;

  if (category == 125)dynamic_byte_parameter[125] = map(integerinput[125], 0, 255, 0, 255);
  speakergainset[24] = float(dynamic_byte_parameter[125]) / 100;




  //129) factory reset tunings
  if ((category == 129) && (integerinput[129] == 1))
  {
    dothetuningsreset = true;
    //Serial.println("129 " + String(0) + " ");
  }


  //130) update GUI by GUI command w/o save
  if (category == 130)
  {
    if (integerinput[130] == 1)
    {
      UpdateGUI();
      loadtoggle = true; //reset load button on GUI
    }
    //GUIactivated = true;
    //glide4.amplitude(1, fadeintime); //fade in if gui in use
  }

  //131) GUI instruction to update GUI with byte parameters to save to disk (encoded 300-517 to avoid conflicts)
  if ((category == 131) && (integerinput[131] == 1))
  {
    dotheGUIupdate = true;
  }


  //  132) save to eeprom
  if (category == 132)
  {
    eepromsavetoggle = map(integerinput[132], 0, 255, 0, 255);
    dotheeepromsave = true;
  }

  if (category == 133)dynamic_byte_parameter[133] = map(integerinput[133], 0, 255, 0, 255);//needed?/
  targetpreset = map(dynamic_byte_parameter[133], 0, 255, 0, 255);


  //134) factory reset
  if (category == 134)
  {
    resettoggle = map(integerinput[134], 0, 255, 0, 255);
    dothefactoryreset = true;
  }

  //135) generate scale
  if (category == 135)
  {
    scaleNumber = map(integerinput[134], 0, 255, 0, 255);
    dotheautoscaleset = true;
  }










  //synchronize to scalefilter
  for (int x = 0; x < 28; x++) scalefilter[x] = 99;
  int tracker1 = 0;
  for (int x = 0; x < 28; x++)
  {
    if (openfilter[x] > 0)//compress the spaces out of openfilter
    {
      //dynamic_byte_parameter[tracker1] = openfilter[x];
      scalefilter[tracker1] = openfilter[x];
      tracker1++;
    }
  }


  if (loadtoggle == true)
  {
    Serial.println("137 " + String(0) + " "); //reset load from disk toggle
    loadtoggle = false;
  }


  //  dc10.amplitude(0);
  //  dc10.amplitude(1, 1000);
  //
  //  AudioInterrupts();
  //
  //  onetime = false;

}//end of updating parameters
