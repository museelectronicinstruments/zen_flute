//C-Major Zen Flute with Physical Modeling Low RF version (FCC approved)

//***************************MIT Software License*******************************
//Copyright (c) 2021 Keith Baxter (info@museelectronicinstruments.com)
//
//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the Software is
//furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all
//copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//SOFTWARE.

//************************** End of MIT License*******************************

//This license is not a hardware license nor an implied license to hardware.
//Please support Muse Electronic Instruments (MEI) in its mission to offer
//innovative electronic instruments by purchasing the Zen Flute and other MEI products.  Thanks.

//***************************************
// libraries and global variables
//***************************************

#include <Audio.h>
#include "flute.h"

flute flute1; //instantiate two flute models using code generated by: https://faustide.grame.fr/
flute flute2;

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

// GUItool: begin automatically generated code
AudioSynthWaveformDc     dc1;            //xy=265,276
AudioSynthWaveformDc     dc2;            //xy=265,318
AudioMixer4              mixer1;         //xy=509,245
AudioOutputI2S           out;            //xy=657,248
AudioConnection          patchCord1(flute1, 0, mixer1, 0);
AudioConnection          patchCord2(flute2, 0, mixer1, 1);
AudioOutputUSB           usb1;           //xy=683,321
AudioConnection          patchCord3(dc1, 0, mixer1, 2);
AudioConnection          patchCord4(dc2, 0, mixer1, 3);
AudioConnection          patchCord5(mixer1, 0, out, 0);
AudioConnection          patchCord6(mixer1, 0, out, 1);
AudioConnection          patchCord7(mixer1, 0, usb1, 0);
AudioConnection          patchCord8(mixer1, 0, usb1, 1);
// GUItool: end automatically generated code

// GUItool: end automatically generated code


#if !defined(ARDUINO_TEENSY40)
#error "Please Select Teensy 4.0 Board Type"
#endif

#if !defined(SERIAL)
#error "USB MIDI not enabled. Please set USB type to 'Serial'."
#endif

//pin assignments Teensy 4.0
const int LEDpin = 13;
const int micInputPin = A0; //mouth microphone
const int mouthSpkrOutput = 12; //mouth speaker output pwm 12 for new RF verson, 15 otherwise
const int closeButton = 2;  //hardware is A2
const int middleButton = 1;
const int farButton = 0;
const int redPin = 5;
const int bluePin = 6;
const int greenPin = 8;
const int modePin = A9;
const int monitorPin = 4;
int WhammyPin = 17;

float adj = 0;

//********************************************************************
// Acoustic Volume Processor Settings
//********************************************************************

bool USB_Midi_on = true;

// tube length to frequency calculated using https://arachnoid.com/polysolve/
const float tubelength[59] = {98.00, 103.83, 110.00, 116.54, 123.47, 130.81, 138.59, 146.83, 155.56, 164.81, 174.61,
                              185.00, 196.00, 207.65, 220.00, 233.08, 246.94, 261.63, 277.18, 293.66,
                              311.13, 329.63, 349.23, 369.99, 392.00, 415.30, 440.00, 466.16, .6384, .5840, .5330,
                              .4815, .4355, .3916, .3495, .3095, .2715, .2355, .2031, .1721, .1415, .1135, .0875,
                              .0630, .0390, .0175,
                              1396.91, 1479.98, 1567.98, 1661.22, 1760.00, 1864.66, 1975.53, 2093.00,
                              2217.46, 2349.32, 2489.02, 2637.02, 2793.83,
                             };



const float chromatic[59] = {98.00, 103.83, 110.00, 116.54, 123.47, 130.81, 138.59, 146.83, 155.56, 164.81, 174.61,
                             185.00, 196.00, 207.65, 220.00, 233.08, 246.94, 261.63, 277.18, 293.66,
                             311.13, 329.63, 349.23, 369.99, 392.00, 415.30, 440.00, 466.16, 493.88,
                             523.25, 554.37, 587.33, 622.25, 659.25, 698.46, 739.99, 783.99, 830.61,
                             880.00, 932.33, 987.77, 1046.50, 1108.73, 1174.66, 1244.51, 1318.51,
                             1396.91, 1479.98, 1567.98, 1661.22, 1760.00, 1864.66, 1975.53, 2093.00,
                             2217.46, 2349.32, 2489.02, 2637.02, 2793.83,
                            };

const int midiconvert[59] = {43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
                             53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
                             63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
                             73, 74, 75, 76, 77, 78, 79, 80, 81, 82,
                             83, 84, 85, 86, 87, 88, 89, 90, 91, 92,
                             93, 94, 95, 96, 97, 98, 99, 100, 101,
                            };

int scalefilter[31] = {2, 4, 5, 7, 9, 10, 12, 14, 16, 17, 19, 21, 22, 24, 26,
                       28, 29, 31, 33, 34, 36, 38, 40, 41, 43, 45, 46, 48, 41, 41, 41
                      }; //cmaj

int scale_type = 0;

//maps chromatic to midi numbers
const int midifilter1[31] = {45, 47, 48, 50, 52, 53, 55, 57, 59, 60, 62, 64, 65, 67, 69,
                             71, 72, 74, 76, 77, 79, 81, 83, 84, 86, 88, 46, 48, 41, 41, 41
                            }; //cmaj

//maps between chromatic and different scales
const int scalefilter1[31] = {2, 4, 5, 7, 9, 10, 12, 14, 16, 17, 19, 21, 22, 24, 26,
                              28, 29, 31, 33, 34, 36, 38, 40, 41, 43, 45, 46, 48, 41, 41, 41
                             }; //cmaj

const int scalefilter2[31] = {2, 5, 7, 9, 12, 14, 17, 19, 21, 24, 24, 26, 29, 31, 33, 36,
                              38, 41, 43, 45, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41
                             }; //c petatonic


const int scalefilter3[31] = { 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
                               25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42
                             }; //chromatic

const int scalefilter4[31] = {1, 3, 6, 11, 13, 15, 18, 20, 23, 25, 27, 30, 32, 35, 37, 39,
                              40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
                             }; //BLACK KEYS

float rootfreq = 0;
float thirdfreq = 0;
float fifthfreq = 0;
float secondfreq = 0;
float sixthfreq = 0;
float target1 = 0;
float target2 = 0;
float target3 = 0;
//float target4 = 0;
//float target5 = 0;

float justifiedtarget1 = 0;
float justifiedtarget2 = 0;
float justifiedtarget3 = 0;

//LUT for mouthspeaker volume

int closestLUTnumber = 0;


//*******Sampling ISR variables and objects*******
// Create an IntervalTimer object to call buffer ISR
IntervalTimer samplingTimer;
const int BUFSIZE = 300;//610;
static volatile int h;  //buffferindex
static volatile int drivebuffer[BUFSIZE];
static volatile int micbuffer[BUFSIZE];
static volatile byte micval, driveval, monitorval;
static volatile int duration = 0;
static float sineincrement = 1;
static float monitorsineincrement = 1;
static unsigned long ISRlasttime = 0;
//https://www.wolframalpha.com/input/?i=table+round%28127*%28sin%282*pi*t%2F100%29%2B1%29%29+from+0+to+99
const int16_t sinetable[100] = {127, 135, 143, 151, 159, 166, 174, 181, 188,
                                195, 202, 208, 214, 220, 225, 230, 234, 238, 242, 245, 248, 250, 252, 253,
                                254, 254, 254, 253, 252, 250, 248, 245, 242, 238, 234, 230, 225, 220, 214,
                                208, 202, 195, 188, 181, 174, 166, 159, 151, 143, 135, 127, 119, 111, 103,
                                95, 88, 80, 73, 66, 59, 52, 46, 40, 34, 29, 24, 20, 16, 12, 9, 6, 4, 2, 1,
                                0, 0, 0, 1, 2, 4, 6, 9, 12, 16, 20, 24, 29, 34, 40, 46, 52, 59, 66, 73, 80,
                                88, 95, 103, 111, 119
                               };
static bool earliest = true;
static int risingedge = 0;

//phase lock variables

//**************************CUSTOM FACTORY TUNING FOR ZEN FLUTE MOUTHPIECE*********************************
bool phasegainboost = 0;
bool volumeboost = 0;
float phasegainset[25] = {8.00, 8.00, 5.00, 4.00, 4.00, 4.50, 6.60, 6.00, 6.00, 8.00, 9.00, 10.00,
                          11.00, 11.00, 11.00, 11.00, 11.00, 11.00, 8.00, 8.00, 8.00, 8.00, 3.00, 3.00, 0.00,
                         };
float derivativegainset[25] = { 0, 0, 0, 0, 0, 0, 0, 0,
                                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                              };
float phasetargetset[25] = {0.10, 0.11, 0.00, 0.07, 0.10, 0.10, 0.10, 0.12, 0.13, 0.16, 0.22, 0.22,
                            0.22, 0.26, 0.27, 0.30, 0.31, 0.30, 0.33, 0.35, 0.35, 0.40, 0.32, 0.50, 0.40,
                           };

float speakergainset[25] = {0.11, 0.11, 0.10, 0.11, 0.04, 0.02, 0.02, 0.04, 0.02, 0.03, 0.03, 0.02,
                            0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.03, 0.03, 0.07, 0.11, 0.11, 0.11, 0.16,
                           };
float phasegain = 3;
//**************************END OF CUSTOM FACTORY TUNING FOR ZEN FLUTE MOUTHPIECE *********************************

float derivativegain = 0;
float phasetarget = .25;
float speakergain = .01;
float phaseshift = 0;
float phaseshift2 = 0;
float phaseshiftdegrees = 0;
float phaseerror = 0;
float previousphaseerror = 0;
float phaseerrordegrees = 0;
float lastphaseerror = 0;
float drivefrequency = 880;
int lastdrivefrequency = 0;
float proportional = 0; //PPL gain block proportional term
float derivative = 0; //PPL gain block derivative term
float fderivative = 0;
int tuningband = 0; //coarse bins for tuning as function of pitch
float boost = 0;

//gain boost variables
unsigned long lastcheck;
float lastfrequency;
float slopemagnitude = 0;
int gaincorrect = 0;
unsigned long boosttimeout = 0;

int tempdrivebuffer[BUFSIZE];
int tempmicbuffer[BUFSIZE];
int startdrive = 0;
float averagemic = 0;
float microphonelevel = 0;
int startmic = 0;
int endmic = 0;
bool found = false;
int lastsample = 0;
float sinelength = 0;
bool capture = false;

// curvefitting variables for finding zero crossings accurately in noise
float ymean = 0;
float xmean = 0;
float lineslopenumerator = 0;
float lineslopedenominator = 0;
float lineslope = 0;
float yintercept = 0;
float precisemicstart = 0;
float precisemicend = 0;

// autoadjust AGC variables
const float SCALESIZE = 28; //number of notes that can be identified (!todo bigger?
const float TOPFREQ = chromatic[45]; //highest frequncy in scale was 1318 hz
const float BOTTOMFREQ = chromatic[27]; //lowest note is 466 hz  /was 25

//closest-note  variables
float closestfrequency = 0;
int closestscalenumber = 0;

//float delta = 0;
//float floatdelta = 0;
float driveerror = 9999;
//float floatdriveerror = 0;

//hysteresis
int hyster_closest_scale_number = 0;
float hysterclosestnote = 0;
int hyster_last_closest_scale_number = 0;
//int closest_chromatic_note_number = 0;
bool newnote = 0;
int hysterpreviousplayednotenumber1 = 0;
int hysterpreviousplayednotenumber2 = 0;
int hysterpreviousplayednotenumber3 = 0;
int hysteresisamount = 5; //smaller is more hysteresis  1/5 here

//********************************************************************
// UI variables
//********************************************************************
bool cherry1 = false; //cherry brand "red" switch states
bool cherry2 = false;
bool cherry3 = false;
bool do1once = false;
bool do2once = false;
bool do3once = false;
unsigned long bouncetimerA1 = 0;
unsigned long bouncetimerB1 = 0;
unsigned long bouncetimerA2 = 0;
unsigned long bouncetimerB2 = 0;
unsigned long bouncetimerA3 = 0;
unsigned long bouncetimerB3 = 0;

unsigned long offtimer = 0;
bool modebutton = false;
unsigned long bouncetimer3 = 0;
int modecount = 1; //start at 1 to signal eeprom empty when 0
int lastmodecount = 1;
unsigned long uncolor = 0;

bool initializeme = false;
bool firsttimesetup = true;
//bool specialprint1 = false;
//bool specialprint2 = false;

bool button1toggle = true;
bool button2toggle = true;
bool button3toggle = true;
bool justonce = true; //part of sleep timer
unsigned long sticktimer = 0;
bool stickoverride = 0;
float locktarget1 = 0;
float locktarget2 = 0;
float locktarget3 = 0;

bool instantbeat = false;
bool cherry1truetoggle = true;
bool cherry2truetoggle = true;
bool cherry3truetoggle = true;
bool cherry1falsetoggle = true;
bool cherry2falsetoggle = true;
bool cherry3falsetoggle = true;
int  binarystate = 0;
int  lastbinarystate = 6;
bool binarystatetoggle0 = false;
bool binarystatetoggle1 = false;
bool binarystatetoggle2 = false;
bool binarystatetoggle3 = false;

//********************************************************************
// Debugging variables
//********************************************************************

unsigned long last_time = millis();
//tuner program
int forceMode = 4; //uses whammypot to set PPL variables
float phasetargetforced = .25;
float phasegainforced = .25;
float drivefrequencyforced = 880;
float derivativegainforced = 0;
float AGCsmoothforced = 1;
float whammyfrequency = 0;

bool LEDtoggle = false;
int displayMode = 0; //0 is synth control, 1 is drum; 2 is save, 3 is debug
bool drumpreview = 0;
unsigned long profiledelta = 0;
unsigned long profiletimer = 0;
bool onetime = true;
//print variables and profiling values
unsigned long printusec = 0;//
unsigned long printusec2 = 0;//
unsigned long printusec3 = 0;//
unsigned long lastprintusec = 0;
unsigned long lastprintusec2 = 0;
bool printscreen = true;


//sweeping variables (for testing only)
int sweepy = 440;
unsigned long usec = 0;//special variable that increments on microseconds
unsigned long lastusec = 0;
unsigned long usec2 = 0;//special variable that increments on microseconds
unsigned long lastusec2 = 0;

//********************************************************************
// Misc variables
//********************************************************************

//sleep timer when not played in a while
unsigned long sleeptimer = 0;
bool woken = false;
bool wokenstall = false;
unsigned long wokentime = 0;
bool lastwoken = true;
bool nochord = true;

//monitor variables
float monitorgain = 1;
float performancegain = 1;

//LUT for monitor volume//not used right now
const float volumecurve[49] =
{ .05, .05, .05, .05, .05, .05, .05, .05, .05, .05,
  .05, .05, .05, .05, .05, .05, .05, .05, .05, .05,
  .05, .05, .05, .05, .05, .05, .05, .05, .05, .05,
  .05, .05, .05, .05, .05, .05, .05, .05, .05, .05,
  .05, .05, .05, .05, .05, .05, .05, .05, .05,
};


float whammyvalue;
float lastwhammyvalue = 0;


// ***************************************
//***************************************
// Setup
//***************************************
//***************************************
void setup()
{
  Serial.begin(9600);
  // audio bus between synth objects.  Set by looking at CPU usage
  AudioMemory(20);

  pinMode(WhammyPin, INPUT);
  mixer1.gain(0, .5);
  mixer1.gain(1, .5);
  mixer1.gain(2, .5);
  mixer1.gain(3, .5);

  analogWriteResolution(8); 
  analogWriteFrequency(mouthSpkrOutput, 30000);
  analogWriteFrequency(monitorPin, 30000);
  analogReadResolution(8);

  samplingTimer.begin(grabdata, 20);  // ISR to grab data (mic and drive wave)every 20 us
  samplingTimer.priority(200);  //0 is bad make this get interrupted by something, why?
  delay(1000);

  //***************I/O*****************
  // pins 7, 20 and 213 used by i2s interface--so leave alone

  pinMode(LEDpin, OUTPUT); //led
  pinMode(micInputPin, INPUT); //microphone A0
  pinMode(mouthSpkrOutput, OUTPUT); //mouth sine output
  pinMode(closeButton, INPUT_PULLUP);
  pinMode(farButton, INPUT_PULLUP);
  pinMode(middleButton, INPUT_PULLUP);

  pinMode(monitorPin, OUTPUT);
  pinMode(WhammyPin, INPUT);
  analogWrite(redPin, 256); //need to set pinmode??
  analogWrite(bluePin, 256);
  analogWrite(greenPin, 256);
  pinMode(modePin, INPUT_PULLUP);

  pinMode(A3, INPUT);  //potentiometer

  flute1.setParamValue("breathGain", .5);
  flute1.setParamValue("breathCutoff", 2000);
  flute1.setParamValue("vibratoFreq", 5);
}

//***************************************
//***************************************
// Main Loop
//***************************************
//***************************************

void loop()
{

  //  profiledelta = micros() - profiletimer;
  //  profiletimer = micros();

  if (capture == true) //have a set of audio data?, if not avoid entire loop until data is captured
  {
    //*************************************************
    //This is the phase tracker
    //monitor the microphone wave and driving speaker to determine
    //the phase shift indicative of resonance--use this phase
    //difference in a phase locked loop to control the drive
    //frequency to measure the oral cavity volume
    //by its resonant frequency
    //*************************************************


    /////////////////////////////////////////
    //detect driving signal, start and length
    /////////////////////////////////////////
    //do this to zero array at current sample for simplicity

    for (int x = 0; x < BUFSIZE; x++)
    {
      tempdrivebuffer[x] = drivebuffer[x];
      tempmicbuffer[x] = micbuffer[x];
      float floaty = micbuffer[x]; //peak microphone value for ppl tuning routine
    }

    //***********************************************************
    //********zero crossing phase detection ********************
    //***********************************************************

    //determine sine length at this frequency
    if (drivefrequency < 0) drivefrequency = 1;  //nan bug figure out later
    sinelength = ((1 / drivefrequency) / .000020); //one sample every 20 usec, **sinelength is samples

    /////////////////////////////////////////
    //detect drive signal signal start
    /////////////////////////////////////////

    startdrive = risingedge; //micbuffer location of drive signal (+zero cross) now provided by ISR

    /////////////////////////////////////////
    //detect microphone signal start
    /////////////////////////////////////////

    //MICROPHONE UP ZERO CROSSING
    //find average of buffer for rough zero crossing calculation
    averagemic = 0;
    //int peakmic = -999;
    for (int x = 0; x < BUFSIZE; x++)
    {
      averagemic = averagemic + tempmicbuffer[x];
      //if (tempmicbuffer[x] > peakmic) peakmic = tempmicbuffer[x];
    }
    averagemic = int(averagemic / BUFSIZE);
    //microphonelevel = (peakmic - averagemic); //now use audio widget
    //averagecount++;

    //find positive going zero crossing
    found = false;
    lastsample = 2000;
    for (int x = startdrive; x < BUFSIZE; x++) //start at drive signal zero crossing
    {
      if (found == false)
      {
        if ((lastsample <= averagemic) && (tempmicbuffer[x] > averagemic))
        {
          found = true;
          startmic = x;  //up zero cross of mic
        }
        lastsample = tempmicbuffer[x];
      }
    }

    //find negative going zero crossing
    found = false;
    lastsample = 2000;
    for (int x = startmic; x < BUFSIZE; x++) //start at drive signal zero crossing
    {
      if (found == false)
      {
        if ((lastsample >= averagemic) && (tempmicbuffer[x] < averagemic))
        {
          found = true;
          endmic = x;  //next down zero cross of mic
        }
        lastsample = tempmicbuffer[x];
      }
    }

    //curvefit around up zero crossing for subsample interpolation
    ymean = 0;
    for (int x = startmic - 5; x < startmic + 6; x++) ymean = ymean + micbuffer[x];
    ymean = ymean / 11;
    xmean = startmic;
    lineslopenumerator = 0;
    lineslopedenominator = 0;
    for (int x = startmic - 5; x < startmic + 6; x++)
    {
      lineslopenumerator = ((x - xmean) * (micbuffer[x] - ymean));
      lineslopedenominator = (x - xmean) * (x - xmean);
    }
    lineslope = lineslopenumerator / lineslopedenominator;
    yintercept = ymean - lineslope * xmean;
    precisemicstart = ((averagemic - yintercept) / lineslope);


    //curvefit around down zero crossing for subsample interpolation
    ymean = 0;
    for (int x = endmic - 5; x < endmic + 6; x++) ymean = ymean + micbuffer[x];
    ymean = ymean / 11;
    xmean = endmic;
    lineslopenumerator = 0;
    lineslopedenominator = 0;
    for (int x = endmic - 5; x < endmic + 6; x++)
    {
      lineslopenumerator = ((x - xmean) * (micbuffer[x] - ymean));
      lineslopedenominator = (x - xmean) * (x - xmean);
    }
    lineslope = lineslopenumerator / lineslopedenominator;
    yintercept = ymean - lineslope * xmean;
    precisemicend = ((averagemic - yintercept) / lineslope);

    phaseshift = precisemicstart - startdrive; //the sample # measure of the phase delay

    int halfwave = int(sinelength / 2);
    phaseshift2 = precisemicend - (startdrive + halfwave); //the sample # measure of the phase delay

    phaseshift = (phaseshift2 + phaseshift) / 2; //corrects waveform zero shift?

    //handles an odd phase shift rollover at low frequecies
    if (phaseshift > (sinelength / 2)) phaseshift = sinelength - phaseshift;

    phaseshiftdegrees = phaseshift / sinelength * 360; // for display
    if (isnan(sinelength)) sinelength = 100; //weird startup bug--figure out later

    //compute phase error in time then degrees
    if (forceMode == 1)phaseerror = phaseshift - (sinelength * phasetargetforced); //tuning mode
    else phaseerror = phaseshift - (sinelength * phasetarget);
    phaseerror = phaseshift - (sinelength * phasetarget);
    phaseerrordegrees = phaseerror / sinelength * 360;


    /////////////////////////////////
    //determine loop gain factors (P and D) according to current pitch bin !!!!!!!!!!
    /////////////////////////////////

    //apply different loop gains depending on note frequency in 25 notes

    if ((drivefrequency <= chromatic[25]) && (drivefrequency > chromatic[24])) //note 2 !!!!!!!
    {
      tuningband = 0;//415
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[0] + (phasegainset[1] - phasegainset[0]) *
                  ((drivefrequency - chromatic[24]) / (chromatic[25] - chromatic[24])); //these are the frequency values bounding the top bin
      //interpolate derivative gain
      derivativegain = derivativegainset[0] + (derivativegainset[1] - derivativegainset[0]) *
                       ((drivefrequency - chromatic[24]) / (chromatic[25] - chromatic[24]));
      //interpolate  phase target
      phasetarget = phasetargetset[0] + (phasetargetset[1] - phasetargetset[0]) *
                    ((drivefrequency - chromatic[24]) / (chromatic[25] - chromatic[24]));
      //interpolate  speaker gain
      speakergain = speakergainset[0] + (speakergainset[1] - speakergainset[0]) *
                    ((drivefrequency - chromatic[24]) / (chromatic[25] - chromatic[24]));

    }
    else if (drivefrequency <= chromatic[26]) //493-659
    {
      tuningband = 1;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[1] + (phasegainset[2] - phasegainset[1]) *
                  ((drivefrequency - chromatic[25]) / (chromatic[26] - chromatic[25]));
      //interpolate derivative gain
      derivativegain = derivativegainset[1] + (derivativegainset[2] - derivativegainset[1]) *
                       ((drivefrequency - chromatic[25]) / (chromatic[26] - chromatic[25]));
      //interpolate  phase target
      phasetarget = phasetargetset[1] + (phasetargetset[2] - phasetargetset[1]) *
                    ((drivefrequency - chromatic[25]) / (chromatic[26] - chromatic[25]));
      //interpolate  speaker gain
      speakergain = speakergainset[1] + (speakergainset[2] - speakergainset[1]) *
                    ((drivefrequency - chromatic[25]) / (chromatic[26] - chromatic[25]));
    }
    else if (drivefrequency <= chromatic[27]) //660-830
    {
      tuningband = 2;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[2] + (phasegainset[3] - phasegainset[2]) *
                  ((drivefrequency - chromatic[26]) / (chromatic[27] - chromatic[26]));
      //interpolate derivative gain
      derivativegain = derivativegainset[2] + (derivativegainset[3] - derivativegainset[2]) *
                       ((drivefrequency - chromatic[26]) / (chromatic[27] - chromatic[26]));
      //interpolate  phase target
      phasetarget = phasetargetset[2] + (phasetargetset[3] - phasetargetset[2]) *
                    ((drivefrequency - chromatic[26]) / (chromatic[27] - chromatic[26]));
      //interpolate  speaker gain
      speakergain = speakergainset[2] + (speakergainset[3] - speakergainset[2]) *
                    ((drivefrequency - chromatic[26]) / (chromatic[27] - chromatic[26]));
    }
    else if (drivefrequency <= chromatic[28]) //831-1046
    {
      tuningband = 3;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[3] + (phasegainset[4] - phasegainset[3]) *
                  ((drivefrequency - chromatic[27]) / (chromatic[28] - chromatic[27]));
      //interpolate derivative gain
      derivativegain = derivativegainset[3] + (derivativegainset[4] - derivativegainset[3]) *
                       ((drivefrequency - chromatic[27]) / (chromatic[28] - chromatic[27]));
      //interpolate  phase target
      phasetarget = phasetargetset[3] + (phasetargetset[4] - phasetargetset[3]) *
                    ((drivefrequency - chromatic[27]) / (chromatic[28] - chromatic[27]));
      //interpolate  speaker gain
      speakergain = speakergainset[3] + (speakergainset[4] - speakergainset[3]) *
                    ((drivefrequency - chromatic[27]) / (chromatic[28] - chromatic[27]));
    }
    else if (drivefrequency <= chromatic[29]) //1044-1244
    {
      tuningband = 4;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[4] + (phasegainset[5] - phasegainset[4]) *
                  ((drivefrequency - chromatic[28]) / (chromatic[29] - chromatic[28]));
      //interpolate derivative gain
      derivativegain = derivativegainset[4] + (derivativegainset[5] - derivativegainset[4]) *
                       ((drivefrequency - chromatic[28]) / (chromatic[29] - chromatic[28]));
      //interpolate  phase target
      phasetarget = phasetargetset[4] + (phasetargetset[5] - phasetargetset[4]) *
                    ((drivefrequency - chromatic[28]) / (chromatic[29] - chromatic[28]));
      //interpolate  speaker gain
      speakergain = speakergainset[4] + (speakergainset[5] - speakergainset[4]) *
                    ((drivefrequency - chromatic[28]) / (chromatic[29] - chromatic[28]));
    }

    else if (drivefrequency <= chromatic[30]) //1245-1661
    {
      tuningband = 5;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[5] + (phasegainset[6] - phasegainset[5]) *
                  ((drivefrequency - chromatic[29]) / (chromatic[30] - chromatic[29]));
      //interpolate derivative gain
      derivativegain = derivativegainset[5] + (derivativegainset[6] - derivativegainset[5]) *
                       ((drivefrequency - chromatic[29]) / (chromatic[30] - chromatic[29]));
      //interpolate  phase target
      phasetarget = phasetargetset[5] + (phasetargetset[6] - phasetargetset[5]) *
                    ((drivefrequency - chromatic[29]) / (chromatic[30] - chromatic[29]));
      //interpolate  speaker gain
      speakergain = speakergainset[5] + (speakergainset[6] - speakergainset[5]) *
                    ((drivefrequency - chromatic[29]) / (chromatic[30] - chromatic[29]));
    }

    else if (drivefrequency <= chromatic[31]) //1245-1661
    {
      tuningband = 6;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[6] + (phasegainset[7] - phasegainset[6]) *
                  ((drivefrequency - chromatic[30]) / (chromatic[31] - chromatic[30]));
      //interpolate derivative gain
      derivativegain = derivativegainset[6] + (derivativegainset[7] - derivativegainset[6]) *
                       ((drivefrequency - chromatic[30]) / (chromatic[31] - chromatic[30]));
      //interpolate  phase target
      phasetarget = phasetargetset[6] + (phasetargetset[7] - phasetargetset[6]) *
                    ((drivefrequency - chromatic[30]) / (chromatic[31] - chromatic[30]));
      //interpolate  speaker gain
      speakergain = speakergainset[6] + (speakergainset[7] - speakergainset[6]) *
                    ((drivefrequency - chromatic[30]) / (chromatic[31] - chromatic[30]));
    }

    else if (drivefrequency <= chromatic[32]) //1245-1661
    {
      tuningband = 7;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[7] + (phasegainset[8] - phasegainset[7]) *
                  ((drivefrequency - chromatic[31]) / (chromatic[32] - chromatic[31]));
      //interpolate derivative gain
      derivativegain = derivativegainset[7] + (derivativegainset[8] - derivativegainset[7]) *
                       ((drivefrequency - chromatic[31]) / (chromatic[32] - chromatic[31]));
      //interpolate  phase target
      phasetarget = phasetargetset[7] + (phasetargetset[8] - phasetargetset[7]) *
                    ((drivefrequency - chromatic[31]) / (chromatic[32] - chromatic[31]));
      //interpolate  speaker gain
      speakergain = speakergainset[7] + (speakergainset[8] - speakergainset[7]) *
                    ((drivefrequency - chromatic[31]) / (chromatic[32] - chromatic[31]));
    }

    else if (drivefrequency <= chromatic[33]) //1245-1661
    {
      tuningband = 8;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[8] + (phasegainset[9] - phasegainset[8]) *
                  ((drivefrequency - chromatic[32]) / (chromatic[33] - chromatic[32]));
      //interpolate derivative gain
      derivativegain = derivativegainset[8] + (derivativegainset[9] - derivativegainset[8]) *
                       ((drivefrequency - chromatic[32]) / (chromatic[33] - chromatic[32]));
      //interpolate  phase target
      phasetarget = phasetargetset[8] + (phasetargetset[9] - phasetargetset[8]) *
                    ((drivefrequency - chromatic[32]) / (chromatic[33] - chromatic[32]));
      //interpolate  speaker gain
      speakergain = speakergainset[8] + (speakergainset[9] - speakergainset[8]) *
                    ((drivefrequency - chromatic[32]) / (chromatic[33] - chromatic[32]));
    }

    else if (drivefrequency <= chromatic[34]) //1245-1661
    {
      tuningband = 9;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[9] + (phasegainset[10] - phasegainset[9]) *
                  ((drivefrequency - chromatic[33]) / (chromatic[34] - chromatic[33]));
      //interpolate derivative gain
      derivativegain = derivativegainset[9] + (derivativegainset[10] - derivativegainset[9]) *
                       ((drivefrequency - chromatic[33]) / (chromatic[34] - chromatic[33]));
      //interpolate  phase target
      phasetarget = phasetargetset[9] + (phasetargetset[10] - phasetargetset[9]) *
                    ((drivefrequency - chromatic[33]) / (chromatic[34] - chromatic[33]));
      //interpolate  speaker gain
      speakergain = speakergainset[9] + (speakergainset[10] - speakergainset[9]) *
                    ((drivefrequency - chromatic[33]) / (chromatic[34] - chromatic[33]));
    }

    else if (drivefrequency <= chromatic[35]) //1245-1661
    {
      tuningband = 10;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[10] + (phasegainset[11] - phasegainset[10]) *
                  ((drivefrequency - chromatic[34]) / (chromatic[35] - chromatic[34]));
      //interpolate derivative gain
      derivativegain = derivativegainset[10] + (derivativegainset[11] - derivativegainset[10]) *
                       ((drivefrequency - chromatic[34]) / (chromatic[35] - chromatic[34]));
      //interpolate  phase target
      phasetarget = phasetargetset[10] + (phasetargetset[11] - phasetargetset[10]) *
                    ((drivefrequency - chromatic[34]) / (chromatic[35] - chromatic[34]));
      //interpolate  speaker gain
      speakergain = speakergainset[10] + (speakergainset[11] - speakergainset[10]) *
                    ((drivefrequency - chromatic[34]) / (chromatic[35] - chromatic[34]));
    }

    else if (drivefrequency <= chromatic[36]) //1245-1661
    {
      tuningband = 11;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[11] + (phasegainset[12] - phasegainset[11]) *
                  ((drivefrequency - chromatic[35]) / (chromatic[36] - chromatic[35]));
      //interpolate derivative gain
      derivativegain = derivativegainset[11] + (derivativegainset[12] - derivativegainset[11]) *
                       ((drivefrequency - chromatic[35]) / (chromatic[36] - chromatic[35]));
      //interpolate  phase target
      phasetarget = phasetargetset[11] + (phasetargetset[12] - phasetargetset[11]) *
                    ((drivefrequency - chromatic[35]) / (chromatic[36] - chromatic[35]));
      //interpolate  speaker gain
      speakergain = speakergainset[11] + (speakergainset[12] - speakergainset[11]) *
                    ((drivefrequency - chromatic[35]) / (chromatic[36] - chromatic[35]));
    }

    else if (drivefrequency <= chromatic[37]) //1245-1661
    {
      tuningband = 12;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[12] + (phasegainset[13] - phasegainset[12]) *
                  ((drivefrequency - chromatic[36]) / (chromatic[37] - chromatic[36]));
      //interpolate derivative gain
      derivativegain = derivativegainset[12] + (derivativegainset[13] - derivativegainset[12]) *
                       ((drivefrequency - chromatic[36]) / (chromatic[37] - chromatic[36]));
      //interpolate  phase target
      phasetarget = phasetargetset[12] + (phasetargetset[13] - phasetargetset[12]) *
                    ((drivefrequency - chromatic[36]) / (chromatic[37] - chromatic[36]));
      //interpolate  speaker gain
      speakergain = speakergainset[12] + (speakergainset[13] - speakergainset[12]) *
                    ((drivefrequency - chromatic[36]) / (chromatic[37] - chromatic[36]));
    }

    else if (drivefrequency <= chromatic[38]) //1245-1661
    {
      tuningband = 13;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[13] + (phasegainset[14] - phasegainset[13]) *
                  ((drivefrequency - chromatic[37]) / (chromatic[38] - chromatic[37]));
      //interpolate derivative gain
      derivativegain = derivativegainset[13] + (derivativegainset[14] - derivativegainset[13]) *
                       ((drivefrequency - chromatic[37]) / (chromatic[38] - chromatic[37]));
      //interpolate  phase target
      phasetarget = phasetargetset[13] + (phasetargetset[14] - phasetargetset[13]) *
                    ((drivefrequency - chromatic[37]) / (chromatic[38] - chromatic[37]));
      //interpolate  speaker gain
      speakergain = speakergainset[13] + (speakergainset[14] - speakergainset[13]) *
                    ((drivefrequency - chromatic[37]) / (chromatic[38] - chromatic[37]));
    }

    else if (drivefrequency <= chromatic[39]) //1245-1661
    {
      tuningband = 14;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[14] + (phasegainset[15] - phasegainset[14]) *
                  ((drivefrequency - chromatic[38]) / (chromatic[39] - chromatic[38]));
      //interpolate derivative gain
      derivativegain = derivativegainset[14] + (derivativegainset[15] - derivativegainset[14]) *
                       ((drivefrequency - chromatic[38]) / (chromatic[39] - chromatic[38]));
      //interpolate  phase target
      phasetarget = phasetargetset[14] + (phasetargetset[15] - phasetargetset[14]) *
                    ((drivefrequency - chromatic[38]) / (chromatic[39] - chromatic[38]));
      //interpolate  speaker gain
      speakergain = speakergainset[14] + (speakergainset[15] - speakergainset[14]) *
                    ((drivefrequency - chromatic[38]) / (chromatic[39] - chromatic[38]));
    }

    else if (drivefrequency <= chromatic[40]) //1245-1661
    {
      tuningband = 15;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[15] + (phasegainset[16] - phasegainset[15]) *
                  ((drivefrequency - chromatic[39]) / (chromatic[40] - chromatic[39]));
      //interpolate derivative gain
      derivativegain = derivativegainset[15] + (derivativegainset[16] - derivativegainset[15]) *
                       ((drivefrequency - chromatic[39]) / (chromatic[40] - chromatic[39]));
      //interpolate  phase target
      phasetarget = phasetargetset[15] + (phasetargetset[16] - phasetargetset[15]) *
                    ((drivefrequency - chromatic[39]) / (chromatic[40] - chromatic[39]));
      //interpolate  speaker gain
      speakergain = speakergainset[15] + (speakergainset[16] - speakergainset[15]) *
                    ((drivefrequency - chromatic[39]) / (chromatic[40] - chromatic[39]));
    }

    else if (drivefrequency <= chromatic[41]) //1245-1661
    {
      tuningband = 16;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[16] + (phasegainset[17] - phasegainset[16]) *
                  ((drivefrequency - chromatic[40]) / (chromatic[41] - chromatic[40]));
      //interpolate derivative gain
      derivativegain = derivativegainset[16] + (derivativegainset[17] - derivativegainset[16]) *
                       ((drivefrequency - chromatic[40]) / (chromatic[41] - chromatic[40]));
      //interpolate  phase target
      phasetarget = phasetargetset[16] + (phasetargetset[17] - phasetargetset[16]) *
                    ((drivefrequency - chromatic[40]) / (chromatic[41] - chromatic[40]));
      //interpolate  speaker gain
      speakergain = speakergainset[16] + (speakergainset[17] - speakergainset[16]) *
                    ((drivefrequency - chromatic[40]) / (chromatic[41] - chromatic[40]));
    }

    else if (drivefrequency <= chromatic[42]) //1245-1661
    {
      tuningband = 17;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[17] + (phasegainset[18] - phasegainset[17]) *
                  ((drivefrequency - chromatic[41]) / (chromatic[42] - chromatic[41]));
      //interpolate derivative gain
      derivativegain = derivativegainset[17] + (derivativegainset[18] - derivativegainset[17]) *
                       ((drivefrequency - chromatic[41]) / (chromatic[42] - chromatic[41]));
      //interpolate  phase target
      phasetarget = phasetargetset[17] + (phasetargetset[18] - phasetargetset[17]) *
                    ((drivefrequency - chromatic[41]) / (chromatic[42] - chromatic[41]));
      //interpolate  speaker gain
      speakergain = speakergainset[17] + (speakergainset[18] - speakergainset[17]) *
                    ((drivefrequency - chromatic[41]) / (chromatic[42] - chromatic[41]));
    }

    else if (drivefrequency <= chromatic[43]) //1245-1661
    {
      tuningband = 18;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[18] + (phasegainset[19] - phasegainset[18]) *
                  ((drivefrequency - chromatic[42]) / (chromatic[43] - chromatic[42]));
      //interpolate derivative gain
      derivativegain = derivativegainset[18] + (derivativegainset[19] - derivativegainset[18]) *
                       ((drivefrequency - chromatic[42]) / (chromatic[43] - chromatic[42]));
      //interpolate  phase target
      phasetarget = phasetargetset[18] + (phasetargetset[19] - phasetargetset[18]) *
                    ((drivefrequency - chromatic[42]) / (chromatic[43] - chromatic[42]));
      //interpolate  speaker gain
      speakergain = speakergainset[18] + (speakergainset[19] - speakergainset[18]) *
                    ((drivefrequency - chromatic[42]) / (chromatic[43] - chromatic[42]));
    }

    else if (drivefrequency <= chromatic[44]) //1245-1661
    {
      tuningband = 19;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[19] + (phasegainset[20] - phasegainset[19]) *
                  ((drivefrequency - chromatic[43]) / (chromatic[44] - chromatic[43]));
      //interpolate derivative gain
      derivativegain = derivativegainset[19] + (derivativegainset[20] - derivativegainset[19]) *
                       ((drivefrequency - chromatic[43]) / (chromatic[44] - chromatic[43]));
      //interpolate  phase target
      phasetarget = phasetargetset[19] + (phasetargetset[20] - phasetargetset[19]) *
                    ((drivefrequency - chromatic[43]) / (chromatic[44] - chromatic[43]));
      //interpolate  speaker gain
      speakergain = speakergainset[19] + (speakergainset[20] - speakergainset[19]) *
                    ((drivefrequency - chromatic[43]) / (chromatic[44] - chromatic[43]));
    }

    else if (drivefrequency <= chromatic[45]) //1245-1661
    {
      tuningband = 20;
      //interpolate phase gain from discrete array values of bins
      phasegain = phasegainset[20] + (phasegainset[21] - phasegainset[20]) *
                  ((drivefrequency - chromatic[44]) / (chromatic[45] - chromatic[44]));
      //interpolate derivative gain
      derivativegain = derivativegainset[20] + (derivativegainset[21] - derivativegainset[20]) *
                       ((drivefrequency - chromatic[44]) / (chromatic[45] - chromatic[44]));
      //interpolate  phase target
      phasetarget = phasetargetset[20] + (phasetargetset[21] - phasetargetset[20]) *
                    ((drivefrequency - chromatic[44]) / (chromatic[45] - chromatic[44]));
      //interpolate  speaker gain
      speakergain = speakergainset[20] + (speakergainset[21] - speakergainset[20]) *
                    ((drivefrequency - chromatic[44]) / (chromatic[45] - chromatic[44]));
    }



    if (speakergain < 0)speakergain = 0;

    if (forceMode == 5)
    {
      derivativegainforced = map(whammyfrequency, 0, 255, 1, 100) / 10000;
      derivativegain = derivativegainforced;
    }

    //***********volume boost on rapid frequency change--could be more sophisticated, e.g continuous
    if (volumeboost == 1)
    {
      fderivative = (lastdrivefrequency - drivefrequency) * .1;//derivativegain; //looks at output derivative
      if ((fderivative) > 4) boost = .02;
      if (boost > 0) boost = boost - .001; //slow fall  to do reactivate with derivative gain
      speakergain = speakergain + boost;
    }
    //***************end of volume boost

    //**********************phasegain boost
    float flyingaverage = (drivefrequency + lastfrequency) / 2;
    slopemagnitude = ((drivefrequency - lastfrequency) / ((millis() - lastcheck) * flyingaverage));
    //slopemagnitude = abs(slopemagnitude);
    lastcheck = millis();
    lastfrequency = drivefrequency;
    //*************end of phasechange boost


    if (phasetarget < 0)phasetarget = 0;
    if (phasegain < 0)phasegain = 0;

    if (phasegainboost == 1)
    {
      if ((drivefrequency > 800) && ((slopemagnitude * 100000) < -400)) //
      {
        phasegain = phasegain + 3;
        gaincorrect = 100;
        boosttimeout = millis() + 25;
      }

      if ((drivefrequency <= 900) && ((slopemagnitude * 100000) > 400))
      {
        phasegain = phasegain + 3;
        gaincorrect = 100;
        boosttimeout = millis() + 25;
      }
    }

    if (boosttimeout > millis())
    {
      phasegain = phasegain + 3;
    }
    else gaincorrect = 0;

    /////////////////////////////////
    //calculate P and D error values
    /////////////////////////////////

    if (forceMode == 2) proportional = (phaseerror * phasegainforced);
    else proportional = (phaseerror * phasegain);


    //derivative = (lastdrivefrequency - drivefrequency) * derivativegain; //looks at output derivative
    //derivative = (previousphaseerror - phaseerror) * derivativegain;
    //should this be based on phaseerror(above)??
    //lastdrivefrequency = drivefrequency;
    previousphaseerror = phaseerror;

    /////////////////////////////////
    //adjust the drive frequency based on proportional and derivative
    /////////////////////////////////

    drivefrequency = drivefrequency - proportional - derivative; // derivative is negative to damp oscillation
    if (isnan(drivefrequency)) drivefrequency = 1200; //bug figure out later

    if (drivefrequency < BOTTOMFREQ) drivefrequency = BOTTOMFREQ;//prevents windup?
    if (drivefrequency > TOPFREQ) drivefrequency = TOPFREQ;

    //set global variable for ISR frequency control
    //if (DISPLAY_MODE == 2) drivefrequency = chromatic[scalefilter[AGCindex]]; //override for AGC adjust


    /////////////////////////////////
    //find closest note for LUT
    /////////////////////////////////

    driveerror = 9999;
    closestfrequency = 0;
    for (int x = 0;  x < 50; x++)
    {
      if (abs(chromatic[x] - drivefrequency) < driveerror)
      {
        driveerror = abs(chromatic[x] - drivefrequency);
        closestLUTnumber = x;
      }
    }

    whammyfrequency = analogRead(WhammyPin);
    if (forceMode == 0)
    {
      drivefrequencyforced = map(whammyfrequency, 0, 255, 393, 1400);
      drivefrequency = drivefrequencyforced;
    }
    if (forceMode == 1) phasetargetforced = map(whammyfrequency, 0, 255, 10, 40) / 100;
    if (forceMode == 2) phasegainforced = map(whammyfrequency, 0, 255, 1, 12);
    if (forceMode == 3) AGCsmoothforced = map(whammyfrequency, 0, 255, 1, 200) / 1000;

    //drivefrequency=1318.51; //override for testing
    sineincrement = (10000 / drivefrequency); //test for drivefreq change?
    
    /////////////////////////////////
    //find closest scale note for quantization
    /////////////////////////////////

    driveerror = 9999;
    closestfrequency = 0;
    for (int x = 0;  x < SCALESIZE; x++)
    {
      if (abs(chromatic[scalefilter[x]] - drivefrequency) < driveerror)
      {
        driveerror = abs(chromatic[scalefilter[x]] - drivefrequency);
        closestfrequency = chromatic[scalefilter[x]];
        closestscalenumber = x;
      }
    }

    /////////////////////////////////
    //recalculate closest scale note for hysteresis
    /////////////////////////////////

    hyster_closest_scale_number = closestscalenumber;
    float A = chromatic[scalefilter[hyster_closest_scale_number]];
    float B = chromatic[scalefilter[hyster_last_closest_scale_number]];
    newnote = false;
    if (A > B)
    {
      if (drivefrequency < ((A + B) / 2) + ((A - B) / hysteresisamount)) // 1/5 is the hysteramount
        hyster_closest_scale_number = hyster_last_closest_scale_number;
    }
    else if (B > A)
    {
      if (drivefrequency > ((A + B) / 2) - ((B - A) / hysteresisamount))
        hyster_closest_scale_number = hyster_last_closest_scale_number;
    }
    else newnote = true;

    hyster_last_closest_scale_number = hyster_closest_scale_number;

    /////////////////////////////////
    // monitor signal amplitude calculation
    /////////////////////////////////

    usec2 = millis();
    if (usec2 > lastusec2 + 100)//
    {
      monitorsineincrement = (10000 / chromatic[scalefilter[hyster_closest_scale_number]]); //test for drivefreq change?
      float tempo = analogRead(WhammyPin);
      if (modecount == 1) monitorgain = tempo / 255;
      performancegain = tempo / 255;
      //monitorgain = volumecurve[hyster_closest_scale_number] * monitorgain;
      if (woken == false) monitorgain = 0;
    }

    /////////////////////////////////////////
    //sleep timer
    /////////////////////////////////////////

    //test sleep timer--turns off mouth speaker after a few seconds
    if ((sleeptimer < millis()) && (woken == true))
    {
      woken = false;  //go to sleep
      wokenstall = false;
    }

    //maintains sleep timer even if not transition of button
    if (cherry1 == true) // || (cherry2 == true) || (cherry3 == true) )
    {
      sleeptimer = millis() + 5000;
      if (woken == false) wokentime = millis();
      woken = true;
    }

    if ((woken == true) && (wokentime + 500 < millis()) ) wokenstall = true; //don't make sound for 2 seconds after mouth spek

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// BEGIN PHYSICAL MODELING
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////
    // SENSING CHERRY SWITCHES 1, 2, 3
    /////////////////////////////////

    //********first switch*********************************************
    if ((digitalRead(closeButton) == false) && (cherry1 == false) && (millis() > bouncetimerB1))
    {
      cherry1 = true;
      bouncetimerA1 = millis() + 50;
    }

    if ((digitalRead(closeButton) == true) && (cherry1 == true) && (millis() > bouncetimerA1))
    {
      cherry1 = false;
      bouncetimerB1 = millis() + 50;
    }

    //********second switch*********************************************
    if ((digitalRead(middleButton) == false) && (cherry2 == false) && (millis() > bouncetimerB2))
    {
      cherry2 = true;
      bouncetimerA2 = millis() + 50;
      if (displayMode == 4) //if in PPL tuning mode, this button captures setting
      {
        if (forceMode == 1)phasetargetset[tuningband] = phasetargetforced;
        if (forceMode == 2)phasegainset[tuningband] = phasegainforced;
        if (forceMode == 3)speakergainset[tuningband] = AGCsmoothforced;
      }
    }

    if ((digitalRead(middleButton) == true) && (cherry2 == true) && (millis() > bouncetimerA2))
    {
      cherry2 = false;
      bouncetimerB2 = millis() + 50;
    }

    //********third switch*********************************************
    if ((digitalRead(farButton) == false) && (cherry3 == false) && (millis() > bouncetimerB3))
    {
      cherry3 = true;
      bouncetimerA3 = millis() + 50;
    }

    if ((digitalRead(farButton) == true) && (cherry3 == true) && (millis() > bouncetimerA3))
    {
      cherry3 = false;
      bouncetimerB3 = millis() + 50;
    }

    //binary encoding  ***************************************************************************
    //****binary state 0********************************************************************************
    if ((cherry2 == false) && (cherry3 == false) && (binarystate != 0))
    {
      binarystatetoggle0 = true;
      binarystate = 0;
    }
    //****binary state 1********************************************************************************
    if ((cherry2 == false) && (cherry3 == true) && (binarystate != 1))
    {
      binarystatetoggle1 = true;
      binarystate = 1;
    }
    //****binary state 2********************************************************************************
    if ((cherry2 == true) && (cherry3 == false) && (binarystate != 2))
    {
      binarystatetoggle2 = true;
      binarystate = 2;
    }
    //****binary state 3********************************************************************************
    if ((cherry2 == true) && (cherry3 == true) && (binarystate != 3))
    {
      binarystatetoggle3 = true;
      binarystate = 3;
    }
    //binary decoding  end***************************************************************************


    //////////////////////////////////////////////////////////
    // 0-FLUTE PLAY
    /////////////////////////////////////////////////////////

    stickoverride = true;

    // tuning if needed
    //    if ((cherry2 == true) &&  (button2toggle == false))
    //    {
    //      button2toggle = true;
    //      adj = adj + .001;
    //      flute1.setParamValue("tubeLength", tubelength[scalefilter[hyster_closest_scale_number]] + adj);
    //      Serial.print("tube length:");
    //      Serial.println(tubelength[scalefilter[hyster_closest_scale_number]] + adj, 4);
    //    }
    //
    //    if ((cherry2 == false) && (button2toggle == true))
    //    {
    //      button2toggle = false;
    //    }
    //
    //    if ((cherry3 == true) &&  (button3toggle == false))
    //    {
    //      button3toggle = true;
    //      adj = adj - .001;
    //      flute1.setParamValue("tubeLength", tubelength[scalefilter[hyster_closest_scale_number]] + adj);
    //      Serial.print("tube length:");
    //      Serial.println(tubelength[scalefilter[hyster_closest_scale_number]] + adj, 4);
    //    }
    //
    //    if ((cherry3 == false) && (button3toggle == true))
    //    {
    //      button3toggle = false;
    //    }



    //  melody section start****************************************************************
    if ((cherry1 == true) &&  (button1toggle == false))
    {
      button1toggle = true;
      sticktimer = millis() + 500; //short time to allow player to slide into correct value
      dc1.amplitude(.8, 100);
      dc2.amplitude(1, 3000);
      AudioNoInterrupts();
      flute1.setParamValue("tubeLength", tubelength[scalefilter[hyster_closest_scale_number]] + adj);
      AudioInterrupts();

    }
    if ((cherry1 == true) && ((sticktimer > millis()) || stickoverride)
        && (hyster_closest_scale_number != hysterpreviousplayednotenumber1))
    {
      AudioNoInterrupts();
      flute1.setParamValue("tubeLength", tubelength[scalefilter[hyster_closest_scale_number]] + adj);
      AudioInterrupts();
      hysterpreviousplayednotenumber1 = hyster_closest_scale_number;      
    }
    if ((cherry1 == false) && (button1toggle == true))
    {
      dc1.amplitude(0, 200);
      dc2.amplitude(0, 10);
      button1toggle = false;
    }

    flute1.setParamValue("pressure", dc1.read());
    whammyvalue = analogRead(WhammyPin);
    whammyvalue = whammyvalue / 256;
    whammyvalue = mapfloat(whammyvalue, 0, 1, .3, .8);
    AudioNoInterrupts();
    flute1.setParamValue("mouthPosition", whammyvalue);
    flute1.setParamValue("vibratoGain", dc2.read());
    AudioInterrupts();

    capture = false; //controls filling buffer
  }//end of capture==true
}//END OF MAIN

////////////////////////////////////////////////////
//     FUNCTIONS
///////////////////////////////////////////////////


//////////////////////////////////////////////////////////
// COLORME FUNCTION  sets led color
/////////////////////////////////////////////////////////
void Colorme(int color)
{
  uncolor = millis();
  switch (color)
  {
    case 1:
      analogWrite(redPin, 256);//off
      analogWrite(bluePin, 256);
      analogWrite(greenPin, 256);
      break;
    case 2:
      analogWrite(redPin, 128);//red
      analogWrite(bluePin, 256);
      analogWrite(greenPin, 256);
      break;
    case 3:
      analogWrite(redPin, 64);//pink
      analogWrite(bluePin, 198);
      analogWrite(greenPin, 198);
      break;
    case 4:
      analogWrite(redPin, 64);//orange
      analogWrite(bluePin, 256);
      analogWrite(greenPin, 172);
      break;
    case 5:
      analogWrite(redPin, 256);//green
      analogWrite(bluePin, 256);
      analogWrite(greenPin, 128);
      break;
    case 6:
      analogWrite(redPin, 128);//yellow
      analogWrite(bluePin, 256);
      analogWrite(greenPin, 128);
      break;
    case 7:
      analogWrite(redPin, 256);//aqua
      analogWrite(bluePin, 128);
      analogWrite(greenPin, 128);
      break;
    case 8:
      analogWrite(redPin, 256);//blue
      analogWrite(bluePin, 128);
      analogWrite(greenPin, 256);
      break;
    case 9:
      analogWrite(redPin, 128);//violet
      analogWrite(bluePin, 128);
      analogWrite(greenPin, 256);
      break;
    case 10:
      analogWrite(redPin, 128); //white
      analogWrite(bluePin, 128);
      analogWrite(greenPin, 128);
      break;
    default:
      // if nothing else matches, do the default
      // default is optional
      break;
  }
}


//////////////////////////////////////////////////////////
// GRABDATA FUNCTION  ISR to buffer microphone samples for analysis
/////////////////////////////////////////////////////////
void grabdata()
{
  //unsigned long starttime = micros(); //for profiling

  //Sine wave output to mouth speaker
  unsigned long temptime = micros();  //figure out sine table lookup
  int tableindex = int((temptime - ISRlasttime) / sineincrement);
  int monitortableindex = int((temptime - ISRlasttime) / monitorsineincrement);
  if (tableindex >= 100) //rising edge is always
  {
    tableindex = 0;
    ISRlasttime = temptime;
  }

  monitorval = int(sinetable[tableindex] * monitorgain);
  AudioNoInterrupts();
  if (woken == true)analogWrite(monitorPin, monitorval);
  if (forceMode == 3) driveval = int(sinetable[tableindex] * AGCsmoothforced);
  else driveval = int(sinetable[tableindex] * speakergain); // grab new reading from drivewave
  if (woken == false) driveval = 0;
  analogWrite(mouthSpkrOutput, driveval);//output to speaker
  AudioInterrupts();

  //read mouth microphone
  if (capture == false) //do this only if new data needed
  {
    micval = analogRead(micInputPin);   // grab new reading from microphone
    micbuffer[h] = micval;
    if ((tableindex == 0) && (earliest == true) && (h > 4))
    {
      risingedge = h;
      earliest = false;
    }
    drivebuffer[h] = driveval; // put new data into buffer
    h++;
    if (h >= BUFSIZE)
    {
      h = 0;
      capture = true; //full data set complete
      earliest = true;
    }
  }
  //duration = int(micros() - starttime);
}

//////////////////////////////////////////////////////////
// MAPFLOAT FUNCTION  map float values to ranges
/////////////////////////////////////////////////////////


float mapfloat(float x, float in_min, float in_max, float out_min, float out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

float bound1(float val)
{
  if (val > 1) return 1;
  if (val < 0) return 0;
  return val;
}
